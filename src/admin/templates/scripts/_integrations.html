        // ========================================
        // DEPLOYMENT STATUS (mode-aware card)
        // ========================================

        // Env snapshot for restart awareness (Task D)
        if (!window._envSnapshot) window._envSnapshot = null;

        function _captureEnvSnapshot() {
            if (envData && Object.keys(envData).length > 0 && !window._envSnapshot) {
                window._envSnapshot = { ...envData };
            }
        }

        function _getChangedSecrets() {
            if (!window._envSnapshot || !envData) return [];
            const changed = [];
            // Only track secrets that matter for Docker container restart
            const trackableKeys = Object.keys(envData).filter(k =>
                !k.startsWith('DEPLOY_') && !k.startsWith('DEADLINE_') &&
                k !== 'MODE' && k !== 'PROJECT_NAME'
            );
            for (const key of trackableKeys) {
                const oldVal = window._envSnapshot[key] || '';
                const newVal = envData[key] || '';
                if (oldVal !== newVal) changed.push(key);
            }
            return changed;
        }

        async function loadDeployStatus() {
            const badge = document.getElementById('deploy-mode-badge');
            const body = document.getElementById('deploy-body');
            if (!body) return;

            // Ensure data is loaded
            if (!appData) {
                try {
                    const resp = await fetch('/api/status');
                    appData = await resp.json();
                } catch (e) {
                    body.innerHTML = `<span style="color: var(--danger);">‚ùå ${e.message}</span>`;
                    return;
                }
            }
            if (!envData || Object.keys(envData).length === 0) {
                try {
                    const envResp = await fetch('/api/env/read');
                    const envResult = await envResp.json();
                    envData = envResult.values || {};
                } catch (e) { /* proceed without env */ }
            }

            // Capture initial snapshot for restart awareness
            _captureEnvSnapshot();

            const mode = appData?.config?.deploy_mode || envData?.DEPLOY_MODE || 'github-pages';

            if (badge) {
                badge.innerHTML = mode === 'docker'
                    ? '<span class="badge warning" style="font-size: 0.75rem;">üê≥ Docker</span>'
                    : '<span class="badge ok" style="font-size: 0.75rem;">üåê GitHub Pages</span>';
            }

            if (mode === 'docker') {
                await _renderDockerCard(body);
            } else {
                _renderGitHubPagesCard(body);
            }
        }

        function _renderGitHubPagesCard(body) {
            const repo = envData?.GITHUB_REPOSITORY || '';
            const parts = repo.split('/');
            const owner = parts[0] || '';
            const repoName = parts[1] || '';
            const pagesUrl = owner && repoName
                ? `https://${owner}.github.io/${repoName}`
                : '';

            let html = '';

            // Pages URL
            if (pagesUrl) {
                html += `
                    <div class="status-row">
                        <span class="status-label">Pages URL</span>
                        <span class="status-value">
                            <a href="${pagesUrl}" target="_blank" style="color: var(--accent);">
                                ${pagesUrl} üîó
                            </a>
                        </span>
                    </div>`;
            }

            // Sentinel status (async ‚Äî fills in after fetch)
            const sentinelUrl = envData?.SENTINEL_URL;
            const sentinelConfigured = !!(sentinelUrl && envData?.SENTINEL_TOKEN);

            if (sentinelConfigured) {
                html += `
                    <div class="status-row">
                        <span class="status-label">Sentinel</span>
                        <span class="status-value" id="sentinel-deploy-status">
                            <span style="color: var(--text-dim);">checking‚Ä¶</span>
                        </span>
                    </div>
                    <div id="sentinel-deploy-details"></div>`;
            } else {
                html += `
                    <div class="status-row">
                        <span class="status-label">Auto tick</span>
                        <span class="status-value">Every 30 min via GitHub Actions cron</span>
                    </div>`;
            }

            // Auto git-sync checkbox
            html += `
                <div style="margin-top: 0.5rem;">
                    <label style="font-size: 0.82rem; display: flex; align-items: center; gap: 0.4rem; cursor: pointer;">
                        <input type="checkbox" id="deploy-auto-sync-ghp" checked>
                        Git sync before deploy
                    </label>
                </div>`;

            // Action buttons
            html += `
                <div class="actions" style="margin-top: 0.5rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    <button class="btn primary" onclick="_deployAction('deploy-site')" id="btn-deploy-pages">
                        üöÄ Deploy Now
                    </button>
                    <button class="btn" onclick="_deployAction('trigger-cron')" id="btn-trigger-cron">
                        üîÑ Trigger Tick
                    </button>
                    ${repo ? `<a class="btn" href="https://github.com/${repo}/actions" target="_blank" style="text-decoration: none;">
                        ‚ö° Actions ‚Üí
                    </a>` : ''}
                </div>`;

            // Status area
            html += `<div id="deploy-action-status" style="font-size: 0.85rem; margin-top: 0.5rem;"></div>`;

            body.innerHTML = html;

            // Fire-and-forget: fetch sentinel status
            if (sentinelConfigured) {
                _loadSentinelDeployStatus(sentinelUrl);
            }
        }

        async function _loadSentinelDeployStatus(sentinelUrl) {
            const statusEl = document.getElementById('sentinel-deploy-status');
            const detailsEl = document.getElementById('sentinel-deploy-details');
            if (!statusEl) return;

            try {
                const resp = await fetch(`${sentinelUrl}/status`, { signal: AbortSignal.timeout(5000) });
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const data = await resp.json();

                // Status badge
                if (data.configured) {
                    statusEl.innerHTML = `<span style="color: var(--accent);">üü¢ Live</span>
                        <span style="font-size: 0.78rem; color: var(--text-dim); margin-left: 0.5rem;">every 60s via Cloudflare</span>`;
                } else {
                    statusEl.innerHTML = `<span style="color: var(--warning);">üü° Deployed but not configured</span>`;
                }

                // Details: last decision, next due, links
                if (detailsEl && data.configured) {
                    let rows = '';

                    if (data.lastDecision) {
                        const action = data.lastDecision.dispatch ? 'üü¢ dispatched' : '‚è≠Ô∏è skipped';
                        const reason = data.lastDecision.reason || '';
                        rows += `
                            <div class="status-row">
                                <span class="status-label">Last decision</span>
                                <span class="status-value" style="font-size: 0.82rem;">${action}${reason ? ` ‚Äî ${reason}` : ''}</span>
                            </div>`;
                    }

                    if (data.nextDueAt) {
                        const nextDue = new Date(data.nextDueAt);
                        const now = new Date();
                        const diffMin = Math.round((nextDue - now) / 60000);
                        const when = diffMin > 0 ? `in ${diffMin}m` : 'now';
                        rows += `
                            <div class="status-row">
                                <span class="status-label">Next due</span>
                                <span class="status-value">${when}</span>
                            </div>`;
                    }

                    // Cloudflare dashboard links
                    const workerName = 'continuity-sentinel';
                    const cfBase = `https://dash.cloudflare.com`;
                    rows += `
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.25rem;">
                            <a href="${cfBase}/?to=/:account/workers/services/view/${workerName}/production/observability/events"
                                target="_blank" class="btn" style="font-size: 0.78rem; padding: 0.25rem 0.6rem; text-decoration: none;">
                                üìä Events
                            </a>
                            <a href="${cfBase}/?to=/:account/workers/services/live-logs/${workerName}/production"
                                target="_blank" class="btn" style="font-size: 0.78rem; padding: 0.25rem 0.6rem; text-decoration: none;">
                                üì° Live Logs
                            </a>
                            <a href="${sentinelUrl}/status"
                                target="_blank" class="btn" style="font-size: 0.78rem; padding: 0.25rem 0.6rem; text-decoration: none;">
                                üîç Status API
                            </a>
                        </div>`;

                    detailsEl.innerHTML = rows;
                }
            } catch (e) {
                statusEl.innerHTML = `<span style="color: var(--danger);">üî¥ Offline</span>
                    <span style="font-size: 0.78rem; color: var(--text-dim); margin-left: 0.5rem;">${e.message}</span>`;
            }
        }

        async function _renderDockerCard(body) {
            let html = '';

            // Fetch Docker status
            let dockerData = null;
            try {
                const resp = await fetch('/api/docker/status');
                dockerData = await resp.json();
            } catch (e) {
                body.innerHTML = `<span style="color: var(--danger);">‚ùå Failed to fetch Docker status: ${e.message}</span>`;
                return;
            }

            if (!dockerData.available) {
                body.innerHTML = `
                    <div class="alert warning">
                        ‚ö†Ô∏è Docker CLI not found. Install Docker to manage containers from here.
                    </div>`;
                return;
            }

            if (!dockerData.compose_file) {
                body.innerHTML = `
                    <div class="alert warning">
                        ‚ö†Ô∏è docker-compose.yml not found in project root.
                    </div>`;
                return;
            }

            // Container status + URLs ‚Äî single aligned table
            const containers = dockerData.containers || [];
            const nginxContainer = containers.find(c => c.name === 'continuity-nginx');
            const nginxRunning = nginxContainer?.status === 'running';
            const tunnelToken = envData?.CLOUDFLARE_TUNNEL_TOKEN;
            const tunnelContainer = containers.find(c => c.name === 'continuity-tunnel');
            const tunnelRunning = tunnelContainer?.status === 'running';

            if (containers.length > 0) {
                html += `<table style="width: 100%; border-collapse: collapse; font-size: 0.82rem; table-layout: fixed;">
                    <colgroup>
                        <col style="width: 1.4rem;">
                        <col>
                        <col style="width: 40%;">
                    </colgroup>`;
                for (const c of containers) {
                    const isRunning = c.status === 'running';
                    const icon = isRunning ? '‚úÖ' : (c.status === 'exited' ? '‚èπ' : '‚ö™');
                    const stateText = c.state || (c.status === 'not_found' ? 'Not started' : c.status);
                    const profileBadge = c.profile
                        ? ` <span style="font-size: 0.7rem; padding: 0.1rem 0.35rem; border-radius: 3px; background: rgba(99,102,241,0.15); color: var(--info); vertical-align: middle;">${c.profile}</span>`
                        : '';
                    html += `
                        <tr style="line-height: 1.8;">
                            <td style="text-align: center;">${icon}</td>
                            <td style="font-family: monospace; color: var(--text); overflow: hidden; text-overflow: ellipsis;">${c.name}${profileBadge}</td>
                            <td style="text-align: right; color: var(--text-dim); overflow: hidden; text-overflow: ellipsis;">${stateText}</td>
                        </tr>`;
                }
                // Separator
                html += `<tr><td colspan="3" style="padding: 0.3rem 0;"><hr style="border: none; border-top: 1px solid var(--border); margin: 0;"></td></tr>`;
                // Local URL row
                html += `
                    <tr style="line-height: 1.8;">
                        <td style="text-align: center;">üåê</td>
                        <td style="color: var(--text-dim);">Local</td>
                        <td style="text-align: right;">
                            ${nginxRunning
                                ? `<a href="http://localhost:8080" target="_blank" style="color: var(--accent);">localhost:8080 üîó</a>`
                                : `<span style="color: var(--text-dim);">localhost:8080</span>`
                            }
                        </td>
                    </tr>`;
                // Tunnel URL row
                if (tunnelToken) {
                    const tUrl = dockerData.tunnel_url;
                    const tErr = dockerData.tunnel_error;
                    let tunnelStatus;
                    if (tunnelRunning && tUrl) {
                        tunnelStatus = `<a href="${tUrl}" target="_blank" style="color: var(--accent);">${tUrl} üîó</a>`;
                    } else if (tunnelRunning && tErr) {
                        tunnelStatus = `<span style="color: var(--warning);" title="${tErr}">‚ö† ${tErr}</span>`;
                    } else if (tunnelRunning) {
                        tunnelStatus = `<span style="color: var(--accent);">Active</span>`;
                    } else {
                        tunnelStatus = `<span style="color: var(--text-dim);">Not running</span>`;
                    }
                    html += `
                        <tr style="line-height: 1.8;">
                            <td style="text-align: center;">üîí</td>
                            <td style="color: var(--text-dim);">Tunnel</td>
                            <td style="text-align: right;">${tunnelStatus}</td>
                        </tr>`;
                }
                html += `</table>`;
            }

            // Git sync config
            const cfg = dockerData.git_sync_config;
            const activeProfiles = dockerData.active_profiles || [];
            const hasGitSync = activeProfiles.includes('git-sync');
            const hasTunnel = activeProfiles.includes('tunnel');

            html += `<div style="display: flex; flex-wrap: wrap; gap: 0.75rem; font-size: 0.82rem; margin-top: 0.25rem;">`;
            if (hasGitSync) {
                const alphaBadge = cfg?.alpha
                    ? '<span class="badge warning">üëë Alpha</span>'
                    : '<span class="badge ok">Non-alpha</span>';
                html += `<div>Git Sync: ${alphaBadge} ¬∑ Tick ${Math.round((cfg?.tick_interval || 900) / 60)}m ¬∑ Sync ${cfg?.sync_interval || 30}s</div>`;
            } else {
                const anyRunning = containers.some(c => c.status === 'running');
                if (anyRunning) {
                    html += `<div style="color: var(--warning);">‚ö†Ô∏è Running in standalone mode (no git sync)</div>`;
                }
            }
            html += `</div>`;


            // Auto git-sync checkbox
            html += `
                <div style="margin-top: 0.5rem;">
                    <label style="font-size: 0.82rem; display: flex; align-items: center; gap: 0.4rem; cursor: pointer;">
                        <input type="checkbox" id="deploy-auto-sync-docker" checked>
                        Auto git-sync before restart
                    </label>
                </div>`;
            // Action buttons ‚Äî primary row
            const anyRunning = containers.some(c => c.status === 'running');
            // Auto-include tunnel profile when a token is configured
            const defaultProfiles = tunnelToken ? ['git-sync', 'tunnel'] : ['git-sync'];
            // Helper: produce a single-quoted JS array literal safe for inline onclick=""
            const jsArr = (arr) => '[' + arr.map(s => `'${s}'`).join(',') + ']';
            html += `<div class="actions" style="margin-top: 0.5rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">`;
            if (anyRunning) {
                html += `
                    <button class="btn primary" onclick="_dockerAction('restart')" id="btn-docker-restart">
                        üîÑ Restart
                    </button>
                    <button class="btn" onclick="_dockerAction('logs')" id="btn-docker-logs">
                        üìã Logs
                    </button>
                    <button class="btn" onclick="_dockerAction('stop')" id="btn-docker-stop">
                        ‚èπ Stop
                    </button>`;
            } else {
                html += `
                    <button class="btn primary" onclick="_dockerStart(${jsArr(defaultProfiles)})" id="btn-docker-start">
                        ‚ñ∂Ô∏è Start &amp; Build (${defaultProfiles.join(' + ')})
                    </button>
                    <button class="btn" onclick="_dockerStart([])" id="btn-docker-start-standalone">
                        ‚ñ∂Ô∏è Start &amp; Build (standalone)
                    </button>`;
            }

            // Tunnel button ‚Äî only if Docker is running but tunnel isn't
            if (tunnelToken && !tunnelRunning && anyRunning) {
                const startWithTunnel = [...(activeProfiles || [])];
                if (!startWithTunnel.includes('tunnel')) startWithTunnel.push('tunnel');
                html += `
                    <button class="btn" onclick="_dockerStart(${jsArr(startWithTunnel)})" id="btn-docker-tunnel">
                        üåê Start Tunnel
                    </button>`;
            }
            html += `</div>`;

            // Secondary actions ‚Äî Build & Clean
            html += `
                <details style="margin-top: 0.5rem;">
                    <summary style="cursor: pointer; font-size: 0.82rem; color: var(--text-dim); user-select: none;">
                        üîß Build & Clean options
                    </summary>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem;">
                        <button class="btn" onclick="_dockerBuild(false)" id="btn-docker-build">
                            üî® Build Images
                        </button>
                        <button class="btn" onclick="_dockerBuild(true)" id="btn-docker-build-clean" title="Ignores Docker layer cache ‚Äî full rebuild from scratch">
                            üî® Build (no cache)
                        </button>
                        <button class="btn" onclick="_dockerClean()" id="btn-docker-clean" style="color: var(--danger);" title="Stop + remove volumes and/or images">
                            üßπ Clean
                        </button>
                    </div>
                </details>`;

            // Restart awareness (Task D)
            const changedSecrets = _getChangedSecrets();
            if (changedSecrets.length > 0 && anyRunning) {
                html += `
                    <div class="alert warning" style="margin-top: 0.75rem;">
                        <strong>‚ö†Ô∏è Restart needed</strong> ‚Äî ${changedSecrets.length} secret${changedSecrets.length > 1 ? 's' : ''} changed since page load
                        <div style="font-size: 0.8rem; margin-top: 0.3rem; color: var(--text-dim);">
                            Changed: ${changedSecrets.join(', ')}
                        </div>
                        <button class="btn primary" onclick="_dockerAction('restart')" style="margin-top: 0.5rem;">
                            üîÑ Apply Changes (Restart)
                        </button>
                    </div>`;
            }

            // Status area
            html += `<div id="deploy-action-status" style="font-size: 0.85rem; margin-top: 0.5rem;"></div>`;

            body.innerHTML = html;
        }

        // ‚îÄ‚îÄ Deploy actions (with git-sync-first flow) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        async function _deployAction(command) {
            const statusDiv = document.getElementById('deploy-action-status');
            const autoSync = document.getElementById('deploy-auto-sync-ghp')?.checked ?? true;

            if (statusDiv) statusDiv.innerHTML = '<span style="color: var(--info);">üîÑ Working...</span>';

            try {
                // Step 1: Git sync if enabled
                if (autoSync) {
                    if (statusDiv) statusDiv.innerHTML = '<span style="color: var(--info);">üì§ Syncing to Git...</span>';
                    const syncResp = await fetch('/api/git/sync', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: 'chore: sync before deploy' }),
                    });
                    const syncData = await syncResp.json();
                    if (!syncData.success) {
                        if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ö†Ô∏è Git sync failed: ${syncData.error || 'Unknown'}</span>`;
                        return;
                    }
                }

                // Step 2: Run the command
                if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--info);">üöÄ Triggering ${command}...</span>`;
                const result = await apiRun(command);

                if (result.success) {
                    if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--accent);">‚úÖ ${command} triggered successfully</span>`;
                } else {
                    if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ùå ${result.error || result.output || 'Failed'}</span>`;
                }
            } catch (e) {
                if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ùå ${e.message}</span>`;
            }
        }

        async function _dockerAction(action) {
            const statusDiv = document.getElementById('deploy-action-status');
            const autoSync = document.getElementById('deploy-auto-sync-docker')?.checked ?? true;

            if (statusDiv) statusDiv.innerHTML = '<span style="color: var(--info);">üîÑ Working...</span>';

            try {
                // Step 1: Git sync before restart (if enabled, and if action warrants it)
                if (autoSync && action === 'restart') {
                    if (statusDiv) statusDiv.innerHTML = '<span style="color: var(--info);">üì§ Syncing to Git first...</span>';
                    const syncResp = await fetch('/api/git/sync', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: 'chore: sync before Docker restart' }),
                    });
                    const syncData = await syncResp.json();
                    if (!syncData.success) {
                        if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ö†Ô∏è Git sync failed: ${syncData.error || 'Unknown'}. Restart aborted.</span>`;
                        return;
                    }
                }

                // Step 2: Docker action
                if (action === 'logs') {
                    if (statusDiv) statusDiv.innerHTML = '<span style="color: var(--info);">üìã Fetching logs...</span>';
                    const resp = await fetch('/api/docker/logs?service=&lines=80');
                    const data = await resp.json();
                    // Show logs in the integration terminal
                    const terminal = document.getElementById('integration-terminal');
                    if (terminal) {
                        terminal.textContent = data.output || data.error || 'No logs available';
                        terminal.scrollTop = terminal.scrollHeight;
                    }
                    if (statusDiv) statusDiv.innerHTML = '<span style="color: var(--accent);">üìã Logs shown below</span>';
                    return;
                }

                const actionLabels = { restart: 'üîÑ Restarting...', stop: '‚èπ Stopping...' };
                if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--info);">${actionLabels[action] || 'üîÑ Working...'}</span>`;

                const resp = await fetch(`/api/docker/${action}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({}),
                });
                const data = await resp.json();

                if (data.success) {
                    if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--accent);">‚úÖ Docker ${action} completed</span>`;
                    // Clear env snapshot on restart (changes are now applied)
                    if (action === 'restart') window._envSnapshot = { ...envData };
                    // Refresh card after a moment
                    setTimeout(loadDeployStatus, 2000);
                } else {
                    if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ùå ${data.error || 'Failed'}</span>`;
                }
            } catch (e) {
                if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ùå ${e.message}</span>`;
            }
        }

        async function _dockerStart(profiles) {
            const statusDiv = document.getElementById('deploy-action-status');
            const profileText = profiles.length > 0 ? profiles.join(' + ') : 'standalone';

            if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--info);">‚ñ∂Ô∏è Building & starting (${profileText})... this may take a moment</span>`;

            try {
                const resp = await fetch('/api/docker/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ profiles }),
                });
                const data = await resp.json();

                if (data.success) {
                    if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--accent);">‚úÖ Containers built & started (${profileText})</span>`;
                    setTimeout(loadDeployStatus, 3000);
                } else {
                    if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ùå ${data.error || 'Failed to start'}</span>`;
                }
            } catch (e) {
                if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ùå ${e.message}</span>`;
            }
        }

        async function _dockerBuild(noCache) {
            const statusDiv = document.getElementById('deploy-action-status');
            const label = noCache ? 'full rebuild (no cache)' : 'build (cached)';

            if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--info);">üî® Running ${label}... this may take a while</span>`;

            try {
                const resp = await fetch('/api/docker/build', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ profiles: ['git-sync'], no_cache: noCache }),
                });
                const data = await resp.json();

                if (data.success) {
                    if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--accent);">‚úÖ Images built successfully (${label})</span>`;
                } else {
                    if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ùå Build failed: ${data.error || 'Unknown'}</span>`;
                }
            } catch (e) {
                if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ùå ${e.message}</span>`;
            }
        }

        async function _dockerClean() {
            const statusDiv = document.getElementById('deploy-action-status');

            // Build confirmation with options
            const choices = prompt(
                'üßπ Docker Clean\n\n' +
                'This will stop all containers and optionally remove data.\n' +
                'Enter the numbers of what to clean (comma-separated):\n\n' +
                '  1 ‚Äî Stop containers only (docker compose down)\n' +
                '  2 ‚Äî Also remove named volumes (‚ö†Ô∏è deletes repo data, state)\n' +
                '  3 ‚Äî Also remove locally-built images\n\n' +
                'Example: "2,3" for full clean, or "1" for just stop.\n' +
                'Cancel to abort.'
            );

            if (!choices) return;

            const nums = choices.split(',').map(s => s.trim());
            const removeVolumes = nums.includes('2');
            const removeImages = nums.includes('3');

            const parts = ['Stop containers'];
            if (removeVolumes) parts.push('remove volumes');
            if (removeImages) parts.push('remove images');
            const desc = parts.join(' + ');

            if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--info);">üßπ Cleaning: ${desc}...</span>`;

            try {
                const resp = await fetch('/api/docker/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        remove_volumes: removeVolumes,
                        remove_images: removeImages,
                    }),
                });
                const data = await resp.json();

                if (data.success) {
                    if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--accent);">‚úÖ Clean complete: ${desc}</span>`;
                    setTimeout(loadDeployStatus, 2000);
                } else {
                    if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ùå Clean failed: ${data.error || 'Unknown'}</span>`;
                }
            } catch (e) {
                if (statusDiv) statusDiv.innerHTML = `<span style="color: var(--danger);">‚ùå ${e.message}</span>`;
            }
        }

        // ========================================
        // INTEGRATIONS TAB
        // ========================================
        const INTEGRATIONS = [
            {
                id: 'email', label: 'Email', adapter: 'email',
                secrets: ['RESEND_API_KEY', 'RESEND_FROM_EMAIL', 'OPERATOR_EMAIL'],
                testCmd: 'test email',
                wizardStep: 'email',
            },
            {
                id: 'sms', label: 'SMS', adapter: 'sms',
                secrets: ['TWILIO_ACCOUNT_SID', 'TWILIO_AUTH_TOKEN', 'TWILIO_FROM_NUMBER', 'OPERATOR_SMS'],
                testCmd: 'test sms',
                wizardStep: 'sms',
            },
            {
                id: 'x', label: 'X / Twitter', adapter: 'x_twitter',
                secrets: ['X_API_KEY', 'X_API_SECRET', 'X_ACCESS_TOKEN', 'X_ACCESS_SECRET'],
                testCmd: 'test x',
                wizardStep: 'twitter',
            },
            {
                id: 'reddit', label: 'Reddit', adapter: 'reddit',
                secrets: ['REDDIT_CLIENT_ID', 'REDDIT_CLIENT_SECRET', 'REDDIT_USERNAME', 'REDDIT_PASSWORD'],
                testCmd: null,
                wizardStep: 'reddit',
            },
        ];

        async function loadIntegrations() {
            if (!appData) {
                const resp = await fetch('/api/status');
                appData = await resp.json();
            }
            if (!envData || Object.keys(envData).length === 0) {
                const envResp = await fetch('/api/env/read');
                const envResult = await envResp.json();
                envData = envResult.values || {};
            }

            // Load mirror status
            loadMirrorStatus();

            // Load deployment status card
            loadDeployStatus();

            for (const integ of INTEGRATIONS) {
                const el = document.getElementById(`integration-${integ.id}`);
                if (!el) continue;

                // Check which secrets are set
                const secretStatus = integ.secrets.map(s => ({
                    name: s,
                    set: !!(envData[s] && envData[s].length > 0),
                }));
                const allSet = secretStatus.every(s => s.set);
                const noneSet = secretStatus.every(s => !s.set);

                // Find adapter status
                const adapter = appData.adapters?.find(a => a.name === integ.adapter);
                const mode = adapter?.configured ? adapter.mode : null;

                let html = '';

                // Secret status
                html += `<div style="display: flex; flex-wrap: wrap; gap: 0.35rem;">`;
                for (const s of secretStatus) {
                    html += `<span style="font-size: 0.78rem; padding: 0.15rem 0.45rem; border-radius: 4px;
                        background: ${s.set ? 'rgba(74,222,128,0.1)' : 'rgba(239,68,68,0.1)'};
                        color: ${s.set ? 'var(--accent)' : 'var(--danger)'};">
                        ${s.set ? '‚úì' : '‚úó'} ${s.name.split('_').slice(-1)[0].toLowerCase()}
                    </span>`;
                }
                html += `</div>`;

                // Mode badge
                if (mode) {
                    html += `<div style="font-size: 0.82rem;">
                        Mode: <span class="badge ${mode === 'real' ? 'ok' : 'warning'}">${mode}</span>
                    </div>`;
                }

                // Actions
                if (allSet && integ.testCmd) {
                    if (integ.id === 'email' || integ.id === 'sms') {
                        const defaultTo = integ.id === 'email'
                            ? (envData['OPERATOR_EMAIL'] || '')
                            : (envData['OPERATOR_SMS'] || '');
                        const placeholder = defaultTo
                            ? `Default: ${defaultTo}`
                            : (integ.id === 'email' ? 'email@example.com' : '+1234567890');
                        html += `
                            <div style="margin-top: 0.4rem;">
                                <label style="font-size: 0.78rem; color: var(--text-dim); margin-bottom: 0.25rem; display: block;">
                                    Send to ${integ.id === 'email' ? '(email)' : '(phone)'}:
                                </label>
                                <input type="${integ.id === 'email' ? 'email' : 'tel'}"
                                    id="test-to-${integ.id}"
                                    placeholder="${placeholder}"
                                    style="width: 100%; box-sizing: border-box; padding: 0.45rem 0.7rem; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 0.85rem; margin-bottom: 0.5rem;" />
                                <button class="btn primary" onclick="runIntegrationTest('${integ.id}')" style="width: 100%;">
                                    üß™ Send Test ${integ.label}
                                </button>
                            </div>`;
                    } else {
                        html += `
                            <div style="margin-top: 0.4rem; display: flex; gap: 0.5rem;">
                                <button class="btn primary" onclick="runIntegrationTest('${integ.id}')" style="flex: 1;">
                                    üîë Verify Credentials
                                </button>
                                ${integ.id === 'x' ? `
                                <button class="btn" onclick="runIntegrationTest('${integ.id}', {post: true})" style="flex: 1;">
                                    üê¶ Post Test Tweet
                                </button>` : ''}
                            </div>`;
                    }
                } else if (allSet && !integ.testCmd) {
                    html += `<div style="color: var(--accent); font-size: 0.85rem;">‚úÖ Configured ‚Äî no test available yet</div>`;
                } else {
                    const missingKeys = secretStatus.filter(s => !s.set).map(s => s.name);
                    html += `
                        <div style="color: var(--warning); font-size: 0.82rem;">
                            Missing: ${missingKeys.join(', ')}
                        </div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button class="btn primary" onclick="goToWizardStep('${integ.wizardStep}')" style="flex: 1;">
                                üßô Setup in Wizard ‚Üí
                            </button>
                            <button class="btn" onclick="switchTab('secrets')" style="flex: 1;">
                                üîê Secrets ‚Üí
                            </button>
                        </div>`;
                }

                // Last test result (persisted in localStorage)
                html += getLastTestHtml(integ.id);

                el.innerHTML = html;
            }
        }

        async function runIntegrationTest(integId, opts) {
            opts = opts || {};
            const terminal = document.getElementById('integration-terminal');
            const toInput = document.getElementById(`test-to-${integId}`);
            const to = toInput?.value?.trim() || '';
            const integ = INTEGRATIONS.find(i => i.id === integId);
            const label = integ ? integ.label : integId;

            terminal.className = 'terminal';
            if (integId === 'email' || integId === 'sms') {
                terminal.textContent = `üß™ Testing ${label}${to ? ` ‚Üí ${to}` : ' (using default)'}...\n`;
            } else if (opts.post) {
                terminal.textContent = `üê¶ Posting test tweet to ${label}...\n`;
            } else {
                terminal.textContent = `üîë Verifying ${label} credentials...\n`;
            }

            try {
                const body = { ...opts };
                if (to) body.to = to;

                const response = await fetch(`/api/test/${integId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                });
                const data = await response.json();

                const testResult = {
                    success: !!data.success,
                    message: data.success
                        ? (data.output || 'Completed successfully')
                        : (data.error || data.output || 'Unknown error'),
                    timestamp: Date.now(),
                    to: to || '(default)',
                };
                localStorage.setItem(`test-result-${integId}`, JSON.stringify(testResult));

                if (data.success) {
                    terminal.textContent = `‚úÖ ${label} test result:\n\n${testResult.message}`;
                } else {
                    terminal.textContent = `‚ùå ${label} test failed:\n\n${testResult.message}`;
                    terminal.className = 'terminal error';
                }

                // Refresh card to show new status
                loadIntegrations();
            } catch (error) {
                const testResult = {
                    success: false,
                    message: error.message,
                    timestamp: Date.now(),
                    to: to || '(default)',
                };
                localStorage.setItem(`test-result-${integId}`, JSON.stringify(testResult));

                terminal.className = 'terminal error';
                terminal.textContent = `‚ùå Error: ${error.message}`;
                loadIntegrations();
            }
        }

