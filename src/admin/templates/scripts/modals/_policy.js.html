        // ‚îÄ‚îÄ Escalation Policy Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        // Preset definitions (must match CLI ‚Äî nested structure)
        const POLICY_PRESETS = {
            default: {
                constants: { remind_1_at_minutes: 360, remind_2_at_minutes: 60, pre_release_at_minutes: 15, partial_after_overdue_minutes: 0, full_after_overdue_minutes: 120, max_failed_attempts: 3 },
            },
            testing: {
                constants: { remind_1_at_minutes: 90, remind_2_at_minutes: 60, pre_release_at_minutes: 30, partial_after_overdue_minutes: 0, full_after_overdue_minutes: 30, max_failed_attempts: 3 },
            },
            direct_full: {
                constants: { remind_1_at_minutes: 0, remind_2_at_minutes: 0, pre_release_at_minutes: 0, partial_after_overdue_minutes: 0, full_after_overdue_minutes: 0, max_failed_attempts: 3 },
                disable: ['R10_ESCALATE_TO_REMIND_1', 'R11_ESCALATE_TO_REMIND_2', 'R12_ESCALATE_TO_PRE_RELEASE', 'R20_ESCALATE_TO_PARTIAL_ON_EXPIRY'],
            },
            gentle: {
                constants: { remind_1_at_minutes: 1440, remind_2_at_minutes: 360, pre_release_at_minutes: 60, partial_after_overdue_minutes: 60, full_after_overdue_minutes: 360, max_failed_attempts: 5 },
            },
        };

        const CONSTANT_KEYS = [
            'remind_1_at_minutes', 'remind_2_at_minutes', 'pre_release_at_minutes',
            'partial_after_overdue_minutes', 'full_after_overdue_minutes', 'max_failed_attempts'
        ];

        let _policyRules = [];  // Cached rule metadata from API

        // Maps rule IDs to the constant input they control
        const RULE_CONSTANT_MAP = {
            'R10_ESCALATE_TO_REMIND_1': 'pc-remind_1_at_minutes',
            'R11_ESCALATE_TO_REMIND_2': 'pc-remind_2_at_minutes',
            'R12_ESCALATE_TO_PRE_RELEASE': 'pc-pre_release_at_minutes',
            'R20_ESCALATE_TO_PARTIAL_ON_EXPIRY': 'pc-partial_after_overdue_minutes',
            'R30_ESCALATE_TO_FULL_AFTER_DELAY': 'pc-full_after_overdue_minutes',
        };

        async function openPolicyModal() {
            const modal = document.getElementById('policy-modal');
            const loading = document.getElementById('policy-loading');
            const body = document.getElementById('policy-body');
            const status = document.getElementById('policy-status');

            modal.style.display = 'block';
            loading.style.display = 'block';
            body.style.display = 'none';
            if (status) status.innerHTML = '';

            try {
                const resp = await fetch('/api/policy/constants');
                const data = await resp.json();

                if (data.error) throw new Error(data.error);

                // Populate constant inputs
                const constants = data.constants || {};
                for (const key of CONSTANT_KEYS) {
                    const input = document.getElementById(`pc-${key}`);
                    if (input) input.value = constants[key] ?? '';
                }

                // Populate rules list
                _policyRules = data.rules || [];
                renderPolicyRules();

                // Sync constant row visibility based on rule state
                syncConstantVisibility();

                // Update labels with human-readable times
                updateTimeLabels();

                // Draw timeline
                renderPolicyTimeline();

                loading.style.display = 'none';
                body.style.display = 'block';
            } catch (err) {
                loading.innerHTML = `<span style="color: var(--error);">‚ùå ${err.message}</span>`;
            }
        }

        function closePolicyModal() {
            document.getElementById('policy-modal').style.display = 'none';
        }

        function renderPolicyRules() {
            const container = document.getElementById('policy-rules-list');
            if (!container) return;

            container.innerHTML = _policyRules.map(r => {
                const isLocked = r.locked;
                const isEnabled = r.enabled;
                const disabledAttr = isLocked ? 'disabled' : '';
                const checkedAttr = isEnabled ? 'checked' : '';
                const icon = isLocked ? 'üîí' : '';
                const opacity = (!isEnabled && !isLocked) ? 'opacity: 0.5;' : '';

                // Short friendly name from id
                const shortId = r.id.replace(/^R\d+_/, '');
                const label = shortId.replace(/_/g, ' ').toLowerCase()
                    .replace(/\b\w/g, c => c.toUpperCase());

                // Tooltip from rule description
                const tooltip = (r.description || '').replace(/"/g, '&quot;');

                return `
                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; cursor: ${isLocked ? 'default' : 'pointer'}; ${opacity}"
                           title="${tooltip}">
                        <input type="checkbox" ${checkedAttr} ${disabledAttr}
                               data-rule-id="${r.id}"
                               onchange="syncConstantVisibility()"
                               style="width: 16px; height: 16px; accent-color: var(--accent);">
                        <span style="font-family: monospace; font-size: 0.78rem; color: var(--text-dim); min-width: 2.5em;">${r.id.match(/^R\d+/)?.[0] || ''}</span>
                        <span style="flex: 1;">${label}</span>
                        ${icon ? `<span>${icon}</span>` : ''}
                        <span style="cursor: help; opacity: 0.4; font-size: 0.75rem;" title="${tooltip}">‚ìò</span>
                    </label>
                `;
            }).join('');
        }

        function syncConstantVisibility() {
            for (const [ruleId, constId] of Object.entries(RULE_CONSTANT_MAP)) {
                const cb = document.querySelector(`input[data-rule-id="${ruleId}"]`);
                const input = document.getElementById(constId);
                if (cb && input) {
                    const row = input.closest('label');
                    if (row) {
                        const enabled = cb.checked;
                        row.style.transition = 'opacity 0.2s, max-height 0.3s';
                        row.style.opacity = enabled ? '1' : '0.3';
                        row.style.maxHeight = enabled ? '3rem' : '0';
                        row.style.overflow = 'hidden';
                        row.style.pointerEvents = enabled ? '' : 'none';
                        // If disabled, don't fully hide ‚Äî show dimmed so user remembers it exists
                        if (!enabled) {
                            row.style.maxHeight = '2rem';
                            row.style.opacity = '0.25';
                        }
                    }
                }
            }
            renderPolicyTimeline();
        }

        function applyPolicyPreset() {
            const select = document.getElementById('policy-preset');
            const presetName = select.value;
            if (!presetName || !POLICY_PRESETS[presetName]) return;

            const preset = POLICY_PRESETS[presetName];
            const constants = preset.constants || preset;
            const disableSet = new Set(preset.disable || []);

            // Apply constant values
            for (const key of CONSTANT_KEYS) {
                const input = document.getElementById(`pc-${key}`);
                if (input && constants[key] !== undefined) input.value = constants[key];
            }

            // Toggle rule checkboxes
            const LOCKED = new Set(['R00_RENEWAL_SUCCESS_RESETS', 'R01_LOCKOUT_ON_MAX_FAILED_ATTEMPTS', 'R90_ENFORCE_MONOTONIC']);
            document.querySelectorAll('[data-rule-id]').forEach(cb => {
                const ruleId = cb.dataset.ruleId;
                if (LOCKED.has(ruleId)) return;
                if (disableSet.has(ruleId)) {
                    cb.checked = false;
                } else {
                    cb.checked = true;
                }
            });

            syncConstantVisibility();
            updateTimeLabels();
            renderPolicyTimeline();
        }

        function _fmtMinutes(mins) {
            if (mins === 0) return 'immediate';
            if (mins < 60) return `${mins}m`;
            if (mins % 60 === 0) return `${mins / 60}h`;
            return `${Math.floor(mins / 60)}h ${mins % 60}m`;
        }

        // Short version for timeline labels (max ~4 chars)
        function _fmtShort(mins) {
            if (mins === 0) return '0';
            if (mins < 60) return `${mins}m`;
            if (mins % 60 === 0) return `${mins / 60}h`;
            return `${Math.floor(mins / 60)}h${mins % 60}`;
        }

        function updateTimeLabels() {
            const labels = {
                'pc-remind_1_label': { suffix: 'before', id: 'pc-remind_1_at_minutes' },
                'pc-remind_2_label': { suffix: 'before', id: 'pc-remind_2_at_minutes' },
                'pc-pre_release_label': { suffix: 'before', id: 'pc-pre_release_at_minutes' },
                'pc-partial_label': { suffix: 'after', id: 'pc-partial_after_overdue_minutes' },
                'pc-full_label': { suffix: 'after', id: 'pc-full_after_overdue_minutes' },
            };
            for (const [labelId, cfg] of Object.entries(labels)) {
                const el = document.getElementById(labelId);
                const input = document.getElementById(cfg.id);
                if (el && input) {
                    const v = parseInt(input.value) || 0;
                    el.textContent = v === 0 ? `(${cfg.suffix === 'after' ? 'immediate' : 'disabled'})` : `= ${_fmtMinutes(v)}`;
                }
            }
        }

        function renderPolicyTimeline() {
            updateTimeLabels();

            const el = document.getElementById('policy-timeline');
            if (!el) return;

            const r1 = parseInt(document.getElementById('pc-remind_1_at_minutes')?.value) || 0;
            const r2 = parseInt(document.getElementById('pc-remind_2_at_minutes')?.value) || 0;
            const pre = parseInt(document.getElementById('pc-pre_release_at_minutes')?.value) || 0;
            const partDelay = parseInt(document.getElementById('pc-partial_after_overdue_minutes')?.value) || 0;
            const fullDelay = parseInt(document.getElementById('pc-full_after_overdue_minutes')?.value) || 0;

            // ‚îÄ‚îÄ Two-zone layout ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // Zone A (compressed): -extMax ‚Üí -r1  (the "safe" zone, far from deadline)
            // Zone B (detailed):   -r1 ‚Üí +fullDelay+30  (the escalation zone)
            //
            // Zone A gets ~12% of the bar width, Zone B gets ~88%
            // This lets the NOW cursor be visible even 24-48h before deadline

            const EXT_MINUTES = 1920;  // 32 hours ‚Äî max extent of compressed zone
            const ZONE_A_PCT = 12;     // % of total bar for compressed zone
            const ZONE_B_PCT = 100 - ZONE_A_PCT;

            const detailSpan = r1 + fullDelay + 30;  // minutes covered by Zone B

            // ‚îÄ‚îÄ Build Zone B segments (detailed) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const segments = [];
            if (r1 > 0) {
                const w = r2 < r1 ? ((r1 - r2) / detailSpan * ZONE_B_PCT) : (r1 / detailSpan * ZONE_B_PCT);
                segments.push({ label: 'OK', width: Math.max(w, 2), color: '#22c55e33', text: '#22c55e' });
            }
            if (r2 > 0 && r2 !== r1) {
                const w = (r2 - pre) / detailSpan * ZONE_B_PCT;
                segments.push({ label: 'R1', width: Math.max(w, 2), color: '#eab30833', text: '#eab308' });
            }
            if (pre > 0 && pre !== r2) {
                const w = pre / detailSpan * ZONE_B_PCT;
                segments.push({ label: 'R2', width: Math.max(w, 2), color: '#f9731633', text: '#f97316' });
            }
            if (pre > 0) {
                const w = pre / detailSpan * ZONE_B_PCT;
                segments.push({ label: 'PRE', width: Math.max(w, 2), color: '#ef444433', text: '#ef4444' });
            }

            // Deadline marker
            segments.push({ label: 'T=0', width: 3, color: '#ffffff22', text: '#fff', isMark: true });

            if (partDelay >= 0) {
                const w = Math.max(partDelay, 1) / detailSpan * ZONE_B_PCT;
                segments.push({ label: 'PART', width: Math.max(w, 4), color: '#ef444455', text: '#ef4444' });
            }
            if (fullDelay >= 0) {
                const afterPart = fullDelay - partDelay;
                const w = Math.max(afterPart, 1) / detailSpan * ZONE_B_PCT;
                segments.push({ label: 'FULL', width: Math.max(w, 4), color: '#dc262666', text: '#dc2626' });
            }

            // ‚îÄ‚îÄ NOW cursor position (piecewise mapping) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // minutesBeforeDeadline: positive = before, negative = after
            let nowPct = null;
            let nowLabel = '';
            let minutesBeforeDeadline = null;

            if (typeof appData !== 'undefined' && appData?.state?.deadline) {
                const deadlineMs = new Date(appData.state.deadline).getTime();
                const nowMs = Date.now();
                minutesBeforeDeadline = (deadlineMs - nowMs) / 60000;

                if (minutesBeforeDeadline > EXT_MINUTES) {
                    // ‚îÄ‚îÄ Scenario 1: Beyond compressed zone (>32h out) ‚Üí clamp to left
                    nowPct = 0.5;
                } else if (minutesBeforeDeadline > r1) {
                    // ‚îÄ‚îÄ Scenario 2: In compressed "safe" zone
                    // Maps EXT_MINUTES ‚Üí 0% and r1 ‚Üí ZONE_A_PCT
                    const ratio = (EXT_MINUTES - minutesBeforeDeadline) / (EXT_MINUTES - r1);
                    nowPct = ratio * ZONE_A_PCT;
                } else if (minutesBeforeDeadline >= -(fullDelay + 30)) {
                    // ‚îÄ‚îÄ Scenario 3: In detailed zone (-r1 to +fullDelay+30)
                    const minutesFromDetailStart = r1 - minutesBeforeDeadline;
                    nowPct = ZONE_A_PCT + (minutesFromDetailStart / detailSpan) * ZONE_B_PCT;
                } else {
                    // ‚îÄ‚îÄ Scenario 4: Way past overdue ‚Üí clamp to right
                    nowPct = 99.5;
                }

                nowPct = Math.max(0, Math.min(100, nowPct));

                // Build label
                const absMins = Math.abs(Math.round(minutesBeforeDeadline));
                if (minutesBeforeDeadline > 0) {
                    nowLabel = _fmtMinutes(absMins) + ' left';
                } else {
                    nowLabel = _fmtMinutes(absMins) + ' overdue';
                }
            }

            // ‚îÄ‚îÄ Build label data for each segment ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // Each segment gets a time label shown at its left edge above the bar
            const labelledSegments = [];
            // SAFE zone
            labelledSegments.push({ flex: ZONE_A_PCT, label: `-${_fmtShort(EXT_MINUTES)}`, dim: true });
            // Detail zone segments with their boundary labels
            for (const seg of segments) {
                const flexVal = seg.isMark ? 4 : Math.max(seg.width, 6);
                let timeLabel = '';
                if (seg.label === 'OK')   timeLabel = `-${_fmtShort(r1)}`;
                if (seg.label === 'R1')   timeLabel = `-${_fmtShort(r2)}`;
                if (seg.label === 'R2')   timeLabel = `-${_fmtShort(pre)}`;
                if (seg.label === 'T=0')  timeLabel = 'T=0';
                if (seg.label === 'PART') timeLabel = `+${_fmtShort(partDelay)}`;
                if (seg.label === 'FULL') timeLabel = `+${_fmtShort(fullDelay)}`;
                labelledSegments.push({ flex: flexVal, label: timeLabel, bold: seg.isMark, seg });
            }

            // ‚îÄ‚îÄ Render HTML ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            let barHtml = '<div style="position: relative;">';

            // Row 1: Time labels above ‚Äî matching flex layout
            barHtml += '<div style="display: flex; font-size: 0.68rem; color: var(--text-dim); margin-bottom: 6px;">';
            for (let i = 0; i < labelledSegments.length; i++) {
                const ls = labelledSegments[i];
                const isLast = (i === labelledSegments.length - 1);
                barHtml += `<div style="
                    flex: ${ls.flex} 1 0%; overflow: hidden; white-space: nowrap;
                    ${isLast ? 'text-align: right;' : 'padding-right: 4px;'}
                    ${ls.bold ? 'font-weight: 600; color: var(--text);' : ''}
                    ${ls.dim ? 'opacity: 0.5;' : ''}
                ">${ls.label}</div>`;
            }
            barHtml += '</div>';

            // Row 2: The bar itself
            barHtml += '<div style="display: flex; height: 28px; border-radius: 6px; overflow: hidden; border: 1px solid var(--border);">';

            // Zone A: compressed safe zone
            barHtml += `<div style="
                flex: ${ZONE_A_PCT} 1 0%;
                background: linear-gradient(90deg, #16a34a11, #22c55e22);
                display: flex; align-items: center; justify-content: center;
                font-size: 0.65rem; font-weight: 600; color: #22c55e60;
                border-right: 1px dashed var(--border);
                white-space: nowrap; overflow: hidden;
                letter-spacing: 0.02em;
            ">SAFE</div>`;

            // Zone B: detailed segments
            for (const seg of segments) {
                const flexVal = seg.isMark ? 4 : Math.max(seg.width, 6);
                barHtml += `<div style="
                    flex: ${flexVal} 1 0%;
                    background: ${seg.color};
                    display: flex; align-items: center; justify-content: center;
                    font-size: 0.72rem; font-weight: 600; color: ${seg.text};
                    ${seg.isMark ? 'border-left: 2px solid white; border-right: 2px solid white;' : ''}
                    white-space: nowrap; overflow: hidden;
                ">${seg.label}</div>`;
            }
            barHtml += '</div>';

            // NOW cursor ‚Äî arrow on top pointing DOWN, "NOW" label below
            if (nowPct !== null) {
                let labelAlign, labelTransform;
                if (nowPct < 8) {
                    labelAlign = 'left: 1px;';
                    labelTransform = 'transform: none;';
                } else if (nowPct > 92) {
                    labelAlign = 'right: 1px;';
                    labelTransform = 'transform: none;';
                } else {
                    labelAlign = 'left: 50%;';
                    labelTransform = 'transform: translateX(-50%);';
                }

                barHtml += `<div style="
                    position: absolute; top: 18px; bottom: -22px;
                    left: ${nowPct}%; transform: translateX(-50%);
                    width: 2px; pointer-events: none; z-index: 5;
                ">
                    <div style="
                        position: absolute; top: 0; left: 50%;
                        transform: translateX(-50%);
                        width: 0; height: 0;
                        border-left: 5px solid transparent;
                        border-right: 5px solid transparent;
                        border-top: 6px solid var(--accent, #60a5fa);
                        filter: drop-shadow(0 0 3px var(--accent, #60a5fa));
                    "></div>
                    <div style="
                        position: absolute; top: 6px; width: 2px; bottom: 14px;
                        background: var(--accent, #60a5fa);
                        box-shadow: 0 0 6px var(--accent, #60a5fa);
                        animation: policyNowPulse 2s ease-in-out infinite;
                    "></div>
                    <div style="
                        position: absolute; bottom: 0; ${labelAlign}
                        ${labelTransform}
                        font-size: 0.62rem; font-weight: 700;
                        color: var(--accent, #60a5fa);
                        white-space: nowrap;
                        text-shadow: 0 0 4px rgba(0,0,0,0.8);
                        letter-spacing: 0.03em;
                    ">NOW</div>
                </div>`;
            }

            barHtml += '</div>';  // Close position: relative wrapper

            // Status line below
            if (nowPct !== null && nowLabel) {
                barHtml += `<div style="
                    text-align: center; margin-top: 1.2rem;
                    font-size: 0.72rem; color: var(--accent, #60a5fa);
                    font-weight: 600;
                ">üìç ${nowLabel}</div>`;
            }

            el.innerHTML = barHtml;

            // Inject styles if not already present
            if (!document.getElementById('policy-tl-styles')) {
                const style = document.createElement('style');
                style.id = 'policy-tl-styles';
                style.textContent = `
                    @keyframes policyNowPulse {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.4; }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        async function savePolicyConstants() {
            const status = document.getElementById('policy-status');
            const saveBtn = document.getElementById('policy-save-btn');

            // Gather constants from inputs
            const constants = {};
            for (const key of CONSTANT_KEYS) {
                const input = document.getElementById(`pc-${key}`);
                if (!input) continue;
                const val = parseInt(input.value);
                if (isNaN(val) || val < 0) {
                    status.innerHTML = `<span style="color: var(--error);">‚ùå Invalid value for ${key.replace(/_/g, ' ')}</span>`;
                    return;
                }
                constants[key] = val;
            }

            // Gather rule toggles
            const enable = [];
            const disable = [];
            document.querySelectorAll('#policy-rules-list input[data-rule-id]').forEach(cb => {
                const ruleId = cb.dataset.ruleId;
                if (cb.disabled) return;  // Skip locked rules
                const original = _policyRules.find(r => r.id === ruleId);
                if (!original) return;
                if (cb.checked && !original.enabled) enable.push(ruleId);
                if (!cb.checked && original.enabled) disable.push(ruleId);
            });

            const payload = { constants, enable, disable };

            status.innerHTML = '<span style="color: var(--info);">‚è≥ Saving...</span>';
            saveBtn.disabled = true;

            try {
                const resp = await fetch('/api/policy/constants', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await resp.json();

                if (!resp.ok || !data.success) {
                    throw new Error(data.error || 'Save failed');
                }

                // Update cached state
                if (data.rules) _policyRules = data.rules;
                status.innerHTML = '<span style="color: var(--success);">‚úÖ Policy saved ‚Äî takes effect on next tick</span>';

                // Git sync if checked
                const syncCb = document.getElementById('policy-git-sync');
                if (syncCb && syncCb.checked) {
                    status.innerHTML += '<br><span style="color: var(--info);">üîÑ Syncing to Git...</span>';
                    try {
                        const syncResp = await fetch('/api/git/sync', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: 'chore: update escalation policy' }),
                        });
                        const syncData = await syncResp.json();
                        if (syncData.success) {
                            status.innerHTML += `<br><span style="color: var(--accent);">‚úÖ ${syncData.message}</span>`;
                        } else {
                            status.innerHTML += `<br><span style="color: var(--warning);">‚ö†Ô∏è ${syncData.error || 'Sync issue'}</span>`;
                        }
                    } catch (syncErr) {
                        status.innerHTML += `<br><span style="color: var(--warning);">‚ö†Ô∏è Git sync failed: ${syncErr.message}</span>`;
                    }
                }

                // Auto-close modal after success
                setTimeout(() => {
                    const modal = document.getElementById('policy-modal');
                    if (modal) modal.style.display = 'none';
                }, 1500);

            } catch (err) {
                status.innerHTML = `<span style="color: var(--error);">‚ùå ${err.message}</span>`;
            } finally {
                saveBtn.disabled = false;
            }
        }
