        // ‚îÄ‚îÄ Escalation Policy Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        // Preset definitions (must match CLI ‚Äî nested structure)
        const POLICY_PRESETS = {
            default: {
                constants: { remind_1_at_minutes: 360, remind_2_at_minutes: 60, pre_release_at_minutes: 15, partial_after_overdue_minutes: 0, full_after_overdue_minutes: 120, max_failed_attempts: 3 },
            },
            testing: {
                constants: { remind_1_at_minutes: 90, remind_2_at_minutes: 60, pre_release_at_minutes: 30, partial_after_overdue_minutes: 0, full_after_overdue_minutes: 30, max_failed_attempts: 3 },
            },
            direct_full: {
                constants: { remind_1_at_minutes: 0, remind_2_at_minutes: 0, pre_release_at_minutes: 0, partial_after_overdue_minutes: 0, full_after_overdue_minutes: 0, max_failed_attempts: 3 },
                disable: ['R10_ESCALATE_TO_REMIND_1', 'R11_ESCALATE_TO_REMIND_2', 'R12_ESCALATE_TO_PRE_RELEASE', 'R20_ESCALATE_TO_PARTIAL_ON_EXPIRY'],
            },
            gentle: {
                constants: { remind_1_at_minutes: 1440, remind_2_at_minutes: 360, pre_release_at_minutes: 60, partial_after_overdue_minutes: 60, full_after_overdue_minutes: 360, max_failed_attempts: 5 },
            },
        };

        const CONSTANT_KEYS = [
            'remind_1_at_minutes', 'remind_2_at_minutes', 'pre_release_at_minutes',
            'partial_after_overdue_minutes', 'full_after_overdue_minutes', 'max_failed_attempts'
        ];

        let _policyRules = [];  // Cached rule metadata from API

        // Maps rule IDs to the constant input they control
        const RULE_CONSTANT_MAP = {
            'R10_ESCALATE_TO_REMIND_1': 'pc-remind_1_at_minutes',
            'R11_ESCALATE_TO_REMIND_2': 'pc-remind_2_at_minutes',
            'R12_ESCALATE_TO_PRE_RELEASE': 'pc-pre_release_at_minutes',
            'R20_ESCALATE_TO_PARTIAL_ON_EXPIRY': 'pc-partial_after_overdue_minutes',
            'R30_ESCALATE_TO_FULL_AFTER_DELAY': 'pc-full_after_overdue_minutes',
        };

        async function openPolicyModal() {
            const modal = document.getElementById('policy-modal');
            const loading = document.getElementById('policy-loading');
            const body = document.getElementById('policy-body');
            const status = document.getElementById('policy-status');

            modal.style.display = 'block';
            loading.style.display = 'block';
            body.style.display = 'none';
            if (status) status.innerHTML = '';

            try {
                const resp = await fetch('/api/policy/constants');
                const data = await resp.json();

                if (data.error) throw new Error(data.error);

                // Populate constant inputs
                const constants = data.constants || {};
                for (const key of CONSTANT_KEYS) {
                    const input = document.getElementById(`pc-${key}`);
                    if (input) input.value = constants[key] ?? '';
                }

                // Populate rules list
                _policyRules = data.rules || [];
                renderPolicyRules();

                // Sync constant row visibility based on rule state
                syncConstantVisibility();

                // Update labels with human-readable times
                updateTimeLabels();

                // Draw timeline
                renderPolicyTimeline();

                loading.style.display = 'none';
                body.style.display = 'block';
            } catch (err) {
                loading.innerHTML = `<span style="color: var(--error);">‚ùå ${err.message}</span>`;
            }
        }

        function closePolicyModal() {
            document.getElementById('policy-modal').style.display = 'none';
        }

        function renderPolicyRules() {
            const container = document.getElementById('policy-rules-list');
            if (!container) return;

            container.innerHTML = _policyRules.map(r => {
                const isLocked = r.locked;
                const isEnabled = r.enabled;
                const disabledAttr = isLocked ? 'disabled' : '';
                const checkedAttr = isEnabled ? 'checked' : '';
                const icon = isLocked ? 'üîí' : '';
                const opacity = (!isEnabled && !isLocked) ? 'opacity: 0.5;' : '';

                // Short friendly name from id
                const shortId = r.id.replace(/^R\d+_/, '');
                const label = shortId.replace(/_/g, ' ').toLowerCase()
                    .replace(/\b\w/g, c => c.toUpperCase());

                // Tooltip from rule description
                const tooltip = (r.description || '').replace(/"/g, '&quot;');

                return `
                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; cursor: ${isLocked ? 'default' : 'pointer'}; ${opacity}"
                           title="${tooltip}">
                        <input type="checkbox" ${checkedAttr} ${disabledAttr}
                               data-rule-id="${r.id}"
                               onchange="syncConstantVisibility()"
                               style="width: 16px; height: 16px; accent-color: var(--accent);">
                        <span style="font-family: monospace; font-size: 0.78rem; color: var(--text-dim); min-width: 2.5em;">${r.id.match(/^R\d+/)?.[0] || ''}</span>
                        <span style="flex: 1;">${label}</span>
                        ${icon ? `<span>${icon}</span>` : ''}
                        <span style="cursor: help; opacity: 0.4; font-size: 0.75rem;" title="${tooltip}">‚ìò</span>
                    </label>
                `;
            }).join('');
        }

        function syncConstantVisibility() {
            for (const [ruleId, constId] of Object.entries(RULE_CONSTANT_MAP)) {
                const cb = document.querySelector(`input[data-rule-id="${ruleId}"]`);
                const input = document.getElementById(constId);
                if (cb && input) {
                    const row = input.closest('label');
                    if (row) {
                        const enabled = cb.checked;
                        row.style.transition = 'opacity 0.2s, max-height 0.3s';
                        row.style.opacity = enabled ? '1' : '0.3';
                        row.style.maxHeight = enabled ? '3rem' : '0';
                        row.style.overflow = 'hidden';
                        row.style.pointerEvents = enabled ? '' : 'none';
                        // If disabled, don't fully hide ‚Äî show dimmed so user remembers it exists
                        if (!enabled) {
                            row.style.maxHeight = '2rem';
                            row.style.opacity = '0.25';
                        }
                    }
                }
            }
            renderPolicyTimeline();
        }

        function applyPolicyPreset() {
            const select = document.getElementById('policy-preset');
            const presetName = select.value;
            if (!presetName || !POLICY_PRESETS[presetName]) return;

            const preset = POLICY_PRESETS[presetName];
            const constants = preset.constants || preset;
            const disableSet = new Set(preset.disable || []);

            // Apply constant values
            for (const key of CONSTANT_KEYS) {
                const input = document.getElementById(`pc-${key}`);
                if (input && constants[key] !== undefined) input.value = constants[key];
            }

            // Toggle rule checkboxes
            const LOCKED = new Set(['R00_RENEWAL_SUCCESS_RESETS', 'R01_LOCKOUT_ON_MAX_FAILED_ATTEMPTS', 'R90_ENFORCE_MONOTONIC']);
            document.querySelectorAll('[data-rule-id]').forEach(cb => {
                const ruleId = cb.dataset.ruleId;
                if (LOCKED.has(ruleId)) return;
                if (disableSet.has(ruleId)) {
                    cb.checked = false;
                } else {
                    cb.checked = true;
                }
            });

            syncConstantVisibility();
            updateTimeLabels();
            renderPolicyTimeline();
        }

        function _fmtMinutes(mins) {
            if (mins === 0) return 'immediate';
            if (mins < 60) return `${mins}m`;
            if (mins % 60 === 0) return `${mins / 60}h`;
            return `${Math.floor(mins / 60)}h ${mins % 60}m`;
        }

        function updateTimeLabels() {
            const labels = {
                'pc-remind_1_label': { suffix: 'before', id: 'pc-remind_1_at_minutes' },
                'pc-remind_2_label': { suffix: 'before', id: 'pc-remind_2_at_minutes' },
                'pc-pre_release_label': { suffix: 'before', id: 'pc-pre_release_at_minutes' },
                'pc-partial_label': { suffix: 'after', id: 'pc-partial_after_overdue_minutes' },
                'pc-full_label': { suffix: 'after', id: 'pc-full_after_overdue_minutes' },
            };
            for (const [labelId, cfg] of Object.entries(labels)) {
                const el = document.getElementById(labelId);
                const input = document.getElementById(cfg.id);
                if (el && input) {
                    const v = parseInt(input.value) || 0;
                    el.textContent = v === 0 ? `(${cfg.suffix === 'after' ? 'immediate' : 'disabled'})` : `= ${_fmtMinutes(v)}`;
                }
            }
        }

        function renderPolicyTimeline() {
            updateTimeLabels();

            const el = document.getElementById('policy-timeline');
            if (!el) return;

            const r1 = parseInt(document.getElementById('pc-remind_1_at_minutes')?.value) || 0;
            const r2 = parseInt(document.getElementById('pc-remind_2_at_minutes')?.value) || 0;
            const pre = parseInt(document.getElementById('pc-pre_release_at_minutes')?.value) || 0;
            const partDelay = parseInt(document.getElementById('pc-partial_after_overdue_minutes')?.value) || 0;
            const fullDelay = parseInt(document.getElementById('pc-full_after_overdue_minutes')?.value) || 0;

            const maxSpan = r1 + fullDelay + 30;

            // Build the bar segments
            const segments = [];
            if (r1 > 0) {
                const w = r2 < r1 ? ((r1 - r2) / maxSpan * 100) : (r1 / maxSpan * 100);
                segments.push({ label: 'OK', width: Math.max(w, 3), color: '#22c55e33', text: '#22c55e' });
            }
            if (r2 > 0 && r2 !== r1) {
                const w = (r2 - pre) / maxSpan * 100;
                segments.push({ label: 'R1', width: Math.max(w, 3), color: '#eab30833', text: '#eab308' });
            }
            if (pre > 0 && pre !== r2) {
                const w = pre / maxSpan * 100;
                segments.push({ label: 'R2', width: Math.max(w, 3), color: '#f9731633', text: '#f97316' });
            }
            if (pre > 0) {
                const w = pre / maxSpan * 100;
                segments.push({ label: 'PRE', width: Math.max(w, 3), color: '#ef444433', text: '#ef4444' });
            }

            // Deadline marker
            segments.push({ label: 'T=0', width: 4, color: '#ffffff22', text: '#fff', isMark: true });

            if (partDelay >= 0) {
                const w = Math.max(partDelay, 1) / maxSpan * 100;
                segments.push({ label: 'PART', width: Math.max(w, 5), color: '#ef444455', text: '#ef4444' });
            }
            if (fullDelay >= 0) {
                const afterPart = fullDelay - partDelay;
                const w = Math.max(afterPart, 1) / maxSpan * 100;
                segments.push({ label: 'FULL', width: Math.max(w, 5), color: '#dc262666', text: '#dc2626' });
            }

            // ‚îÄ‚îÄ NOW cursor position ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // The timeline spans from -r1 (left edge) to +fullDelay+30 (right edge)
            // "minutesBeforeDeadline" is how many minutes until T=0
            // Positive = before deadline, negative = after deadline
            let nowPct = null;
            let nowLabel = '';
            if (typeof appData !== 'undefined' && appData?.state?.deadline) {
                const deadlineMs = new Date(appData.state.deadline).getTime();
                const nowMs = Date.now();
                const minutesBeforeDeadline = (deadlineMs - nowMs) / 60000;

                // Position on timeline: -r1 maps to 0%, +fullDelay+30 maps to 100%
                // "minutesFromStart" = how far from the left edge (-r1)
                const minutesFromStart = r1 - minutesBeforeDeadline;
                nowPct = (minutesFromStart / maxSpan) * 100;

                // Clamp to visible range with small margin
                if (nowPct >= -2 && nowPct <= 102) {
                    nowPct = Math.max(0, Math.min(100, nowPct));
                    // Build label
                    const absMins = Math.abs(Math.round(minutesBeforeDeadline));
                    if (minutesBeforeDeadline > 0) {
                        nowLabel = _fmtMinutes(absMins) + ' left';
                    } else {
                        nowLabel = _fmtMinutes(absMins) + ' overdue';
                    }
                } else {
                    nowPct = null;  // Out of visible range
                }
            }

            // ‚îÄ‚îÄ Render HTML ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            let barHtml = '<div style="position: relative;">';

            // Bar segments
            barHtml += '<div style="display: flex; height: 28px; border-radius: 6px; overflow: hidden; border: 1px solid var(--border);">';
            for (const seg of segments) {
                barHtml += `<div style="
                    width: ${seg.width}%; min-width: ${seg.isMark ? '3px' : '24px'};
                    background: ${seg.color};
                    display: flex; align-items: center; justify-content: center;
                    font-size: 0.72rem; font-weight: 600; color: ${seg.text};
                    ${seg.isMark ? 'border-left: 2px solid white; border-right: 2px solid white;' : ''}
                    white-space: nowrap; overflow: hidden; text-overflow: clip;
                ">${seg.label}</div>`;
            }
            barHtml += '</div>';

            // NOW cursor overlay
            if (nowPct !== null) {
                barHtml += `<div style="
                    position: absolute; top: -6px; bottom: -22px;
                    left: ${nowPct}%; transform: translateX(-50%);
                    width: 2px; pointer-events: none; z-index: 5;
                ">
                    <div style="
                        width: 2px; height: calc(28px + 6px);
                        background: var(--accent, #60a5fa);
                        box-shadow: 0 0 6px var(--accent, #60a5fa);
                        animation: policyNowPulse 2s ease-in-out infinite;
                    "></div>
                    <div style="
                        position: absolute; top: -5px; left: 50%;
                        transform: translateX(-50%);
                        width: 0; height: 0;
                        border-left: 5px solid transparent;
                        border-right: 5px solid transparent;
                        border-top: 6px solid var(--accent, #60a5fa);
                        filter: drop-shadow(0 0 3px var(--accent, #60a5fa));
                    "></div>
                    <div style="
                        position: absolute; bottom: -2px; left: 50%;
                        transform: translateX(-50%);
                        font-size: 0.62rem; font-weight: 700;
                        color: var(--accent, #60a5fa);
                        white-space: nowrap;
                        text-shadow: 0 0 4px rgba(0,0,0,0.8);
                        letter-spacing: 0.03em;
                    ">NOW</div>
                </div>`;
            }

            barHtml += '</div>';  // Close position: relative wrapper

            // Labels below ‚Äî extra margin to avoid NOW label collision
            barHtml += '<div style="display: flex; justify-content: space-between; margin-top: 0.55rem; font-size: 0.72rem; color: var(--text-dim);">';
            barHtml += `<span>-${_fmtMinutes(r1)}</span>`;
            if (r2 > 0 && r2 !== r1) barHtml += `<span>-${_fmtMinutes(r2)}</span>`;
            if (pre > 0 && pre !== r2) barHtml += `<span>-${_fmtMinutes(pre)}</span>`;
            barHtml += '<span style="font-weight: 600;">T=0</span>';
            if (partDelay > 0) barHtml += `<span>+${_fmtMinutes(partDelay)}</span>`;
            barHtml += `<span>+${_fmtMinutes(fullDelay)}</span>`;
            barHtml += '</div>';

            // Status line showing current position in text
            if (nowPct !== null && nowLabel) {
                barHtml += `<div style="
                    text-align: center; margin-top: 0.35rem;
                    font-size: 0.72rem; color: var(--accent, #60a5fa);
                    font-weight: 600;
                ">üìç ${nowLabel}</div>`;
            }

            el.innerHTML = barHtml;

            // Inject pulse animation if not already present
            if (!document.getElementById('policy-now-pulse-style')) {
                const style = document.createElement('style');
                style.id = 'policy-now-pulse-style';
                style.textContent = `
                    @keyframes policyNowPulse {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.4; }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        async function savePolicyConstants() {
            const status = document.getElementById('policy-status');
            const saveBtn = document.getElementById('policy-save-btn');

            // Gather constants from inputs
            const constants = {};
            for (const key of CONSTANT_KEYS) {
                const input = document.getElementById(`pc-${key}`);
                if (!input) continue;
                const val = parseInt(input.value);
                if (isNaN(val) || val < 0) {
                    status.innerHTML = `<span style="color: var(--error);">‚ùå Invalid value for ${key.replace(/_/g, ' ')}</span>`;
                    return;
                }
                constants[key] = val;
            }

            // Gather rule toggles
            const enable = [];
            const disable = [];
            document.querySelectorAll('#policy-rules-list input[data-rule-id]').forEach(cb => {
                const ruleId = cb.dataset.ruleId;
                if (cb.disabled) return;  // Skip locked rules
                const original = _policyRules.find(r => r.id === ruleId);
                if (!original) return;
                if (cb.checked && !original.enabled) enable.push(ruleId);
                if (!cb.checked && original.enabled) disable.push(ruleId);
            });

            const payload = { constants, enable, disable };

            status.innerHTML = '<span style="color: var(--info);">‚è≥ Saving...</span>';
            saveBtn.disabled = true;

            try {
                const resp = await fetch('/api/policy/constants', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await resp.json();

                if (!resp.ok || !data.success) {
                    throw new Error(data.error || 'Save failed');
                }

                // Update cached state
                if (data.rules) _policyRules = data.rules;
                status.innerHTML = '<span style="color: var(--success);">‚úÖ Policy saved ‚Äî takes effect on next tick</span>';

                // Git sync if checked
                const syncCb = document.getElementById('policy-git-sync');
                if (syncCb && syncCb.checked) {
                    status.innerHTML += '<br><span style="color: var(--info);">üîÑ Syncing to Git...</span>';
                    try {
                        const syncResp = await fetch('/api/git/sync', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: 'chore: update escalation policy' }),
                        });
                        const syncData = await syncResp.json();
                        if (syncData.success) {
                            status.innerHTML += `<br><span style="color: var(--accent);">‚úÖ ${syncData.message}</span>`;
                        } else {
                            status.innerHTML += `<br><span style="color: var(--warning);">‚ö†Ô∏è ${syncData.error || 'Sync issue'}</span>`;
                        }
                    } catch (syncErr) {
                        status.innerHTML += `<br><span style="color: var(--warning);">‚ö†Ô∏è Git sync failed: ${syncErr.message}</span>`;
                    }
                }

                // Auto-close modal after success
                setTimeout(() => {
                    const modal = document.getElementById('policy-modal');
                    if (modal) modal.style.display = 'none';
                }, 1500);

            } catch (err) {
                status.innerHTML = `<span style="color: var(--error);">‚ùå ${err.message}</span>`;
            } finally {
                saveBtn.disabled = false;
            }
        }
