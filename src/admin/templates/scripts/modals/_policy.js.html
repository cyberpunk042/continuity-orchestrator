        // ‚îÄ‚îÄ Escalation Policy Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        // Preset definitions (must match CLI ‚Äî nested structure)
        const POLICY_PRESETS = {
            default: {
                constants: { remind_1_at_minutes: 360, remind_2_at_minutes: 60, pre_release_at_minutes: 15, partial_after_overdue_minutes: 0, full_after_overdue_minutes: 120, max_failed_attempts: 3 },
            },
            testing: {
                constants: { remind_1_at_minutes: 90, remind_2_at_minutes: 60, pre_release_at_minutes: 30, partial_after_overdue_minutes: 0, full_after_overdue_minutes: 30, max_failed_attempts: 3 },
            },
            direct_full: {
                constants: { remind_1_at_minutes: 0, remind_2_at_minutes: 0, pre_release_at_minutes: 0, partial_after_overdue_minutes: 0, full_after_overdue_minutes: 0, max_failed_attempts: 3 },
                disable: ['R10_ESCALATE_TO_REMIND_1', 'R11_ESCALATE_TO_REMIND_2', 'R12_ESCALATE_TO_PRE_RELEASE', 'R20_ESCALATE_TO_PARTIAL_ON_EXPIRY'],
            },
            gentle: {
                constants: { remind_1_at_minutes: 1440, remind_2_at_minutes: 360, pre_release_at_minutes: 60, partial_after_overdue_minutes: 60, full_after_overdue_minutes: 360, max_failed_attempts: 5 },
            },
        };

        const CONSTANT_KEYS = [
            'remind_1_at_minutes', 'remind_2_at_minutes', 'pre_release_at_minutes',
            'partial_after_overdue_minutes', 'full_after_overdue_minutes', 'max_failed_attempts'
        ];

        let _policyRules = [];  // Cached rule metadata from API

        // Maps rule IDs to the constant input they control
        const RULE_CONSTANT_MAP = {
            'R10_ESCALATE_TO_REMIND_1': 'pc-remind_1_at_minutes',
            'R11_ESCALATE_TO_REMIND_2': 'pc-remind_2_at_minutes',
            'R12_ESCALATE_TO_PRE_RELEASE': 'pc-pre_release_at_minutes',
            'R20_ESCALATE_TO_PARTIAL_ON_EXPIRY': 'pc-partial_after_overdue_minutes',
            'R30_ESCALATE_TO_FULL_AFTER_DELAY': 'pc-full_after_overdue_minutes',
        };

        async function openPolicyModal() {
            const modal = document.getElementById('policy-modal');
            const loading = document.getElementById('policy-loading');
            const body = document.getElementById('policy-body');
            const status = document.getElementById('policy-status');

            modal.style.display = 'block';
            loading.style.display = 'block';
            body.style.display = 'none';
            if (status) status.innerHTML = '';

            try {
                const resp = await fetch('/api/policy/constants');
                const data = await resp.json();

                if (data.error) throw new Error(data.error);

                // Populate constant inputs
                const constants = data.constants || {};
                for (const key of CONSTANT_KEYS) {
                    const input = document.getElementById(`pc-${key}`);
                    if (input) input.value = constants[key] ?? '';
                }

                // Populate rules list
                _policyRules = data.rules || [];
                renderPolicyRules();

                // Sync constant row visibility based on rule state
                syncConstantVisibility();

                // Update labels with human-readable times
                updateTimeLabels();

                // Draw timeline
                renderPolicyTimeline();

                loading.style.display = 'none';
                body.style.display = 'block';
            } catch (err) {
                loading.innerHTML = `<span style="color: var(--error);">‚ùå ${err.message}</span>`;
            }
        }

        function closePolicyModal() {
            document.getElementById('policy-modal').style.display = 'none';
        }

        function renderPolicyRules() {
            const container = document.getElementById('policy-rules-list');
            if (!container) return;

            container.innerHTML = _policyRules.map(r => {
                const isLocked = r.locked;
                const isEnabled = r.enabled;
                const disabledAttr = isLocked ? 'disabled' : '';
                const checkedAttr = isEnabled ? 'checked' : '';
                const icon = isLocked ? 'üîí' : '';
                const opacity = (!isEnabled && !isLocked) ? 'opacity: 0.5;' : '';

                // Short friendly name from id
                const shortId = r.id.replace(/^R\d+_/, '');
                const label = shortId.replace(/_/g, ' ').toLowerCase()
                    .replace(/\b\w/g, c => c.toUpperCase());

                // Tooltip from rule description
                const tooltip = (r.description || '').replace(/"/g, '&quot;');

                return `
                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; cursor: ${isLocked ? 'default' : 'pointer'}; ${opacity}"
                           title="${tooltip}">
                        <input type="checkbox" ${checkedAttr} ${disabledAttr}
                               data-rule-id="${r.id}"
                               onchange="syncConstantVisibility()"
                               style="width: 16px; height: 16px; accent-color: var(--accent);">
                        <span style="font-family: monospace; font-size: 0.78rem; color: var(--text-dim); min-width: 2.5em;">${r.id.match(/^R\d+/)?.[0] || ''}</span>
                        <span style="flex: 1;">${label}</span>
                        ${icon ? `<span>${icon}</span>` : ''}
                        <span style="cursor: help; opacity: 0.4; font-size: 0.75rem;" title="${tooltip}">‚ìò</span>
                    </label>
                `;
            }).join('');
        }

        function syncConstantVisibility() {
            for (const [ruleId, constId] of Object.entries(RULE_CONSTANT_MAP)) {
                const cb = document.querySelector(`input[data-rule-id="${ruleId}"]`);
                const input = document.getElementById(constId);
                if (cb && input) {
                    const row = input.closest('label');
                    if (row) {
                        const enabled = cb.checked;
                        row.style.transition = 'opacity 0.2s, max-height 0.3s';
                        row.style.opacity = enabled ? '1' : '0.3';
                        row.style.maxHeight = enabled ? '3rem' : '0';
                        row.style.overflow = 'hidden';
                        row.style.pointerEvents = enabled ? '' : 'none';
                        // If disabled, don't fully hide ‚Äî show dimmed so user remembers it exists
                        if (!enabled) {
                            row.style.maxHeight = '2rem';
                            row.style.opacity = '0.25';
                        }
                    }
                }
            }
            renderPolicyTimeline();
        }

        function applyPolicyPreset() {
            const select = document.getElementById('policy-preset');
            const presetName = select.value;
            if (!presetName || !POLICY_PRESETS[presetName]) return;

            const preset = POLICY_PRESETS[presetName];
            const constants = preset.constants || preset;
            const disableSet = new Set(preset.disable || []);

            // Apply constant values
            for (const key of CONSTANT_KEYS) {
                const input = document.getElementById(`pc-${key}`);
                if (input && constants[key] !== undefined) input.value = constants[key];
            }

            // Toggle rule checkboxes
            const LOCKED = new Set(['R00_RENEWAL_SUCCESS_RESETS', 'R01_LOCKOUT_ON_MAX_FAILED_ATTEMPTS', 'R90_ENFORCE_MONOTONIC']);
            document.querySelectorAll('[data-rule-id]').forEach(cb => {
                const ruleId = cb.dataset.ruleId;
                if (LOCKED.has(ruleId)) return;
                if (disableSet.has(ruleId)) {
                    cb.checked = false;
                } else {
                    cb.checked = true;
                }
            });

            syncConstantVisibility();
            updateTimeLabels();
            renderPolicyTimeline();
        }

        function _fmtMinutes(mins) {
            if (mins === 0) return 'immediate';
            if (mins < 60) return `${mins}m`;
            if (mins % 60 === 0) return `${mins / 60}h`;
            return `${Math.floor(mins / 60)}h ${mins % 60}m`;
        }

        function updateTimeLabels() {
            const labels = {
                'pc-remind_1_label': { suffix: 'before', id: 'pc-remind_1_at_minutes' },
                'pc-remind_2_label': { suffix: 'before', id: 'pc-remind_2_at_minutes' },
                'pc-pre_release_label': { suffix: 'before', id: 'pc-pre_release_at_minutes' },
                'pc-partial_label': { suffix: 'after', id: 'pc-partial_after_overdue_minutes' },
                'pc-full_label': { suffix: 'after', id: 'pc-full_after_overdue_minutes' },
            };
            for (const [labelId, cfg] of Object.entries(labels)) {
                const el = document.getElementById(labelId);
                const input = document.getElementById(cfg.id);
                if (el && input) {
                    const v = parseInt(input.value) || 0;
                    el.textContent = v === 0 ? `(${cfg.suffix === 'after' ? 'immediate' : 'disabled'})` : `= ${_fmtMinutes(v)}`;
                }
            }
        }

        function renderPolicyTimeline() {
            updateTimeLabels();

            const el = document.getElementById('policy-timeline');
            if (!el) return;

            const r1 = parseInt(document.getElementById('pc-remind_1_at_minutes')?.value) || 0;
            const r2 = parseInt(document.getElementById('pc-remind_2_at_minutes')?.value) || 0;
            const pre = parseInt(document.getElementById('pc-pre_release_at_minutes')?.value) || 0;
            const partDelay = parseInt(document.getElementById('pc-partial_after_overdue_minutes')?.value) || 0;
            const fullDelay = parseInt(document.getElementById('pc-full_after_overdue_minutes')?.value) || 0;

            // Build stages array ‚Äî each represents a segment on the timeline
            // Timeline goes from left (earliest) to right (latest)
            const stages = [];
            const total = Math.max(r1 + fullDelay, 1);  // Total span for proportional widths

            // Before-deadline stages (negative time, min before)
            const beforeStages = [
                { label: 'OK', start: -r1, end: -r2, color: '#22c55e' },
                { label: 'R1', start: -r2, end: -pre, color: '#eab308' },
                { label: 'R2', start: -pre, end: 0, color: '#f97316' },
                { label: 'PRE', start: 0, end: 0, color: '#ef4444' },
            ];

            // After-deadline stages
            const afterStages = [
                { label: 'PART', start: partDelay, end: fullDelay, color: '#ef4444' },
                { label: 'FULL', start: fullDelay, end: fullDelay + 30, color: '#dc2626' },
            ];

            // Render as a horizontal bar
            const barWidth = 100;  // percentage
            const allPoints = [r1, r2, pre, 0, partDelay, fullDelay].filter(v => v >= 0);
            const maxSpan = r1 + fullDelay + 30;

            // Build the bar segments
            let barHtml = '<div style="display: flex; height: 28px; border-radius: 6px; overflow: hidden; border: 1px solid var(--border);">';

            const segments = [];
            if (r1 > 0) {
                // OK segment: from -r1 to -r2
                const w = r2 < r1 ? ((r1 - r2) / maxSpan * 100) : (r1 / maxSpan * 100);
                segments.push({ label: 'OK', width: Math.max(w, 3), color: '#22c55e33', text: '#22c55e' });
            }
            if (r2 > 0 && r2 !== r1) {
                const w = (r2 - pre) / maxSpan * 100;
                segments.push({ label: 'R1', width: Math.max(w, 3), color: '#eab30833', text: '#eab308' });
            }
            if (pre > 0 && pre !== r2) {
                const w = pre / maxSpan * 100;
                segments.push({ label: 'R2', width: Math.max(w, 3), color: '#f9731633', text: '#f97316' });
            }
            if (pre > 0) {
                const w = pre / maxSpan * 100;
                segments.push({ label: 'PRE', width: Math.max(w, 3), color: '#ef444433', text: '#ef4444' });
            }

            // Deadline marker
            segments.push({ label: 'T=0', width: 4, color: '#ffffff22', text: '#fff', isMark: true });

            if (partDelay >= 0) {
                const w = Math.max(partDelay, 1) / maxSpan * 100;
                segments.push({ label: 'PART', width: Math.max(w, 5), color: '#ef444455', text: '#ef4444' });
            }
            if (fullDelay >= 0) {
                const afterPart = fullDelay - partDelay;
                const w = Math.max(afterPart, 1) / maxSpan * 100;
                segments.push({ label: 'FULL', width: Math.max(w, 5), color: '#dc262666', text: '#dc2626' });
            }

            for (const seg of segments) {
                barHtml += `<div style="
                    width: ${seg.width}%; min-width: ${seg.isMark ? '3px' : '24px'};
                    background: ${seg.color};
                    display: flex; align-items: center; justify-content: center;
                    font-size: 0.72rem; font-weight: 600; color: ${seg.text};
                    ${seg.isMark ? 'border-left: 2px solid white; border-right: 2px solid white;' : ''}
                    white-space: nowrap; overflow: hidden; text-overflow: clip;
                ">${seg.label}</div>`;
            }

            barHtml += '</div>';

            // Labels below
            barHtml += '<div style="display: flex; justify-content: space-between; margin-top: 0.35rem; font-size: 0.72rem; color: var(--text-dim);">';
            barHtml += `<span>-${_fmtMinutes(r1)}</span>`;
            if (r2 > 0 && r2 !== r1) barHtml += `<span>-${_fmtMinutes(r2)}</span>`;
            if (pre > 0 && pre !== r2) barHtml += `<span>-${_fmtMinutes(pre)}</span>`;
            barHtml += '<span style="font-weight: 600;">T=0</span>';
            if (partDelay > 0) barHtml += `<span>+${_fmtMinutes(partDelay)}</span>`;
            barHtml += `<span>+${_fmtMinutes(fullDelay)}</span>`;
            barHtml += '</div>';

            el.innerHTML = barHtml;
        }

        async function savePolicyConstants() {
            const status = document.getElementById('policy-status');
            const saveBtn = document.getElementById('policy-save-btn');

            // Gather constants from inputs
            const constants = {};
            for (const key of CONSTANT_KEYS) {
                const input = document.getElementById(`pc-${key}`);
                if (!input) continue;
                const val = parseInt(input.value);
                if (isNaN(val) || val < 0) {
                    status.innerHTML = `<span style="color: var(--error);">‚ùå Invalid value for ${key.replace(/_/g, ' ')}</span>`;
                    return;
                }
                constants[key] = val;
            }

            // Gather rule toggles
            const enable = [];
            const disable = [];
            document.querySelectorAll('#policy-rules-list input[data-rule-id]').forEach(cb => {
                const ruleId = cb.dataset.ruleId;
                if (cb.disabled) return;  // Skip locked rules
                const original = _policyRules.find(r => r.id === ruleId);
                if (!original) return;
                if (cb.checked && !original.enabled) enable.push(ruleId);
                if (!cb.checked && original.enabled) disable.push(ruleId);
            });

            const payload = { constants, enable, disable };

            status.innerHTML = '<span style="color: var(--info);">‚è≥ Saving...</span>';
            saveBtn.disabled = true;

            try {
                const resp = await fetch('/api/policy/constants', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await resp.json();

                if (!resp.ok || !data.success) {
                    throw new Error(data.error || 'Save failed');
                }

                // Update cached state
                if (data.rules) _policyRules = data.rules;
                status.innerHTML = '<span style="color: var(--success);">‚úÖ Policy saved ‚Äî takes effect on next tick</span>';

                // Git sync if checked
                const syncCb = document.getElementById('policy-git-sync');
                if (syncCb && syncCb.checked) {
                    status.innerHTML += '<br><span style="color: var(--info);">üîÑ Syncing to Git...</span>';
                    try {
                        const syncResp = await fetch('/api/git/sync', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: 'chore: update escalation policy' }),
                        });
                        const syncData = await syncResp.json();
                        if (syncData.success) {
                            status.innerHTML += `<br><span style="color: var(--accent);">‚úÖ ${syncData.message}</span>`;
                        } else {
                            status.innerHTML += `<br><span style="color: var(--warning);">‚ö†Ô∏è ${syncData.error || 'Sync issue'}</span>`;
                        }
                    } catch (syncErr) {
                        status.innerHTML += `<br><span style="color: var(--warning);">‚ö†Ô∏è Git sync failed: ${syncErr.message}</span>`;
                    }
                }

                // Auto-close modal after success
                setTimeout(() => {
                    const modal = document.getElementById('policy-modal');
                    if (modal) modal.style.display = 'none';
                }, 1500);

            } catch (err) {
                status.innerHTML = `<span style="color: var(--error);">‚ùå ${err.message}</span>`;
            } finally {
                saveBtn.disabled = false;
            }
        }
