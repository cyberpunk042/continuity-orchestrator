        // Secrets form
        let ghSecrets = [];  // List of secrets set in GitHub
        let ghVariables = [];  // List of variables set in GitHub
        let currentTarget = 'both';  // Current save target

        function selectTarget(target) {
            currentTarget = target;
            // Update button states
            document.querySelectorAll('.target-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.target === target);
            });
            // Update save button label
            const btn = document.getElementById('save-secrets-btn');
            if (btn) {
                const labels = { both: 'üíæ Save & Push', local: 'üìÅ Save', github: '‚òÅÔ∏è Push' };
                btn.textContent = labels[target];
            }
        }

        // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        // ‚îÇ ‚ö†Ô∏è  CRITICAL: These tiers control what gets pushed to GitHub.       ‚îÇ
        // ‚îÇ  If a value is NOT in the right list, it stays "Local only" and     ‚îÇ
        // ‚îÇ  the pipeline will NOT have it. Keep in sync with:                  ‚îÇ
        // ‚îÇ   - .github/workflows/cron.yml  (env: blocks)                      ‚îÇ
        // ‚îÇ   - src/mirror/github_sync.py   (SYNCABLE_SECRETS / SYNCABLE_VARS) ‚îÇ
        // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

        // Three-tier classification of .env values based on actual GitHub workflow usage
        // Tier 1: Actual GitHub secrets (consumed via secrets.* in workflows, or via CONTINUITY_CONFIG)
        const GITHUB_SECRETS = [
            'CONTINUITY_CONFIG',  // Master JSON ‚Äî overrides individual secrets
            'RESEND_API_KEY', 'RESEND_FROM_EMAIL',
            'TWILIO_ACCOUNT_SID', 'TWILIO_AUTH_TOKEN', 'TWILIO_FROM_NUMBER',
            'X_API_KEY', 'X_API_SECRET', 'X_ACCESS_TOKEN', 'X_ACCESS_SECRET',
            'REDDIT_CLIENT_ID', 'REDDIT_CLIENT_SECRET', 'REDDIT_USERNAME', 'REDDIT_PASSWORD',
            'PERSISTENCE_API_URL', 'PERSISTENCE_API_KEY',
            'RENEWAL_SECRET', 'RELEASE_SECRET', 'RENEWAL_TRIGGER_TOKEN', 'CONTENT_ENCRYPTION_KEY',
            'OPERATOR_EMAIL', 'OPERATOR_SMS', 'PROJECT_NAME',
            'MIRROR_1_TOKEN', 'MIRROR_1_RENEWAL_TRIGGER_TOKEN', 'ADMIN_TOKEN',
        ];
        // Tier 2: GitHub repository variables (consumed via vars.* in workflows ‚Äî NOT secrets)
        const GITHUB_VARS = ['ADAPTER_MOCK_MODE', 'ARCHIVE_ENABLED', 'ARCHIVE_URL', 'MIRROR_ENABLED', 'MIRROR_1_REPO', 'MIRROR_RESET_MODE'];
        // Tier 3: Local-only config (.env only, never referenced in workflows)
        const LOCAL_ONLY = ['DEPLOY_MODE', 'WEBHOOK_TIMEOUT'];
        // Auto-provided by GitHub Actions runtime ‚Äî can't be set/deleted via API
        const AUTO_PROVIDED = ['GITHUB_TOKEN', 'GITHUB_REPOSITORY'];
        // Combined known secrets (for sync/clear operations)
        const KNOWN_SECRETS = [...GITHUB_SECRETS, ...GITHUB_VARS, ...LOCAL_ONLY, ...AUTO_PROVIDED];
        // Env var names that feed the master config JSON (mirrors buildMasterConfigJson)
        const MASTER_CONFIG_ENVVARS = [
            'PROJECT_NAME', 'OPERATOR_EMAIL', 'OPERATOR_SMS',
            'RESEND_API_KEY', 'RESEND_FROM_EMAIL',
            'TWILIO_ACCOUNT_SID', 'TWILIO_AUTH_TOKEN', 'TWILIO_FROM_NUMBER',
            'X_API_KEY', 'X_API_SECRET', 'X_ACCESS_TOKEN', 'X_ACCESS_SECRET',
            'REDDIT_CLIENT_ID', 'REDDIT_CLIENT_SECRET', 'REDDIT_USERNAME', 'REDDIT_PASSWORD',
            // NOT GITHUB_TOKEN/GITHUB_REPOSITORY ‚Äî auto-provided by GitHub Actions at runtime
            'PERSISTENCE_API_URL', 'PERSISTENCE_API_KEY',
            'RENEWAL_SECRET', 'RELEASE_SECRET', 'RENEWAL_TRIGGER_TOKEN',
        ];

        function getSecretTier(name) {
            if (AUTO_PROVIDED.includes(name)) return 'auto';
            if (GITHUB_SECRETS.includes(name)) return 'secret';
            if (GITHUB_VARS.includes(name)) return 'var';
            return 'local';
        }

        async function loadSecretsForm() {
            if (!appData) {
                const response = await fetch('/api/status');
                appData = await response.json();
            }

            // Re-fetch env data so we always have the latest .env values
            const envRes = await fetch('/api/env/read');
            const envResult = await envRes.json();
            envData = envResult.values || {};

            // Fetch GitHub secrets + variables list
            const ghSecretsRes = await fetch('/api/gh/secrets');
            const ghSecretsData = await ghSecretsRes.json();
            ghSecrets = ghSecretsData.secrets || [];
            ghVariables = ghSecretsData.variables || [];

            const ghTool = appData.tools.find(t => t.name === 'gh');
            const gitTool = appData.tools.find(t => t.name === 'git');
            const ghAlert = document.getElementById('gh-status-alert');

            if (!ghTool?.installed) {
                ghAlert.innerHTML = `
                    <div class="alert warning" style="display: flex; align-items: center; justify-content: space-between;">
                        <span>‚ö†Ô∏è <strong>gh CLI not installed</strong></span>
                        <span style="display: flex; gap: 0.5rem;">
                            <button class="btn" onclick="installGh()" style="padding: 0.25rem 0.75rem;">Install gh CLI</button>
                            <button class="btn" onclick="refreshSecrets()" style="padding: 0.25rem 0.5rem;" title="Refresh">üîÑ</button>
                        </span>
                    </div>
                `;
            } else if (!ghTool?.authenticated) {
                ghAlert.innerHTML = `
                    <div class="alert warning" style="display: flex; align-items: center; justify-content: space-between;">
                        <span>‚ö†Ô∏è <strong>gh CLI not authenticated</strong> ‚Äî Run <code>gh auth login</code> in terminal.</span>
                        <button class="btn" onclick="refreshSecrets()" style="padding: 0.25rem 0.5rem;" title="Refresh">üîÑ</button>
                    </div>
                `;
            } else {
                ghAlert.innerHTML = `
                    <div class="alert success" style="display: flex; align-items: center; justify-content: space-between;">
                        <span>‚úÖ <strong>gh CLI ready</strong> ‚Äî ${ghSecrets.length} secrets in repo.</span>
                        <button class="btn" onclick="refreshSecrets()" style="padding: 0.25rem 0.5rem;" title="Refresh">üîÑ</button>
                    </div>
                `;
            }

            // Group secrets by category
            const categories = {
                'Project': ['PROJECT_NAME', 'OPERATOR_EMAIL', 'OPERATOR_SMS'],
                'Security': ['RENEWAL_SECRET', 'RELEASE_SECRET', 'RENEWAL_TRIGGER_TOKEN', 'CONTENT_ENCRYPTION_KEY'],
                'Email (Resend)': ['RESEND_API_KEY', 'RESEND_FROM_EMAIL'],
                'SMS (Twilio)': ['TWILIO_ACCOUNT_SID', 'TWILIO_AUTH_TOKEN', 'TWILIO_FROM_NUMBER'],
                'GitHub': ['GITHUB_TOKEN', 'GITHUB_REPOSITORY'],
                'X (Twitter)': ['X_API_KEY', 'X_API_SECRET', 'X_ACCESS_TOKEN', 'X_ACCESS_SECRET'],
                'Reddit': ['REDDIT_CLIENT_ID', 'REDDIT_CLIENT_SECRET', 'REDDIT_USERNAME', 'REDDIT_PASSWORD'],
                'Repo Mirror': ['MIRROR_ENABLED', 'MIRROR_1_REPO', 'MIRROR_1_TOKEN', 'MIRROR_1_RENEWAL_TRIGGER_TOKEN', 'MIRROR_RESET_MODE'],
                'Operational': ['ADAPTER_MOCK_MODE', 'ARCHIVE_ENABLED', 'ARCHIVE_URL'],
            };

            let html = '';

            // Map categories to wizard steps for shortcut links
            const categoryWizardMap = {
                'Email (Resend)': 'email',
                'SMS (Twilio)': 'sms',
                'X (Twitter)': 'twitter',
                'Reddit': 'reddit',
                'Security': 'security',
                'Repo Mirror': 'mirror',
            };

            for (const [category, names] of Object.entries(categories)) {
                const secrets = names.map(name => appData.secrets.find(s => s.name === name)).filter(Boolean);
                if (secrets.length === 0) continue;

                const wizLink = categoryWizardMap[category]
                    ? ` <a href="#wizard/${categoryWizardMap[category]}" onclick="goToWizardStep('${categoryWizardMap[category]}'); return false;" style="font-size: 0.75rem; color: var(--info); font-weight: normal; margin-left: 0.5rem;" title="Open guided setup in Wizard">üßô Wizard ‚Üí</a>`
                    : '';
                html += `<div class="section-title">${category}${wizLink}</div>`;
                for (const secret of secrets) {
                    const isRequired = secret.required_for.length > 0;
                    const localSet = envData[secret.name] && envData[secret.name].length > 0;
                    const ghSet = ghSecrets.includes(secret.name);
                    const currentValue = envData[secret.name] || '';

                    // Boolean secrets use select dropdown
                    const booleanSecrets = ['ADAPTER_MOCK_MODE', 'ARCHIVE_ENABLED', 'MIRROR_ENABLED'];

                    // Non-sensitive secrets can show as plain text
                    const nonSensitive = ['GITHUB_REPOSITORY', 'OPERATOR_EMAIL', 'RESEND_FROM_EMAIL',
                        'TWILIO_FROM_NUMBER', 'OPERATOR_SMS', 'PROJECT_NAME',
                        'REDDIT_USERNAME', 'TWILIO_ACCOUNT_SID', 'REDDIT_CLIENT_ID',
                        'ARCHIVE_URL', 'WEBHOOK_TIMEOUT', 'DEPLOY_MODE',
                        'PERSISTENCE_API_URL', 'MIRROR_1_REPO'];

                    // Add action buttons for certain secrets
                    let actionBtn = '';
                    if (secret.name === 'GITHUB_TOKEN' || secret.name === 'GITHUB_REPOSITORY') {
                        actionBtn = `<button type="button" class="btn" onclick="fillSecretFromGh('${secret.name}')" style="padding:0.25rem 0.5rem;font-size:0.75rem;" title="Get from gh CLI">üîç</button>`;
                    } else if (secret.name === 'CONTENT_ENCRYPTION_KEY') {
                        actionBtn = `<button type="button" class="btn" onclick="generateContentKey()" style="padding:0.25rem 0.5rem;font-size:0.75rem;" title="Generate a new encryption key">üîë</button>`;
                    }

                    // Determine input type
                    let inputHtml = '';
                    if (booleanSecrets.includes(secret.name)) {
                        // Only ADAPTER_MOCK_MODE defaults to On when unset (safe testing);
                        // all other booleans default to Off.
                        const defaultsToOn = ['ADAPTER_MOCK_MODE'];
                        const isTrue = localSet
                            ? (currentValue === 'true' || currentValue === '1')
                            : defaultsToOn.includes(secret.name);

                        // Context-appropriate labels
                        const isMockMode = secret.name === 'ADAPTER_MOCK_MODE';
                        const onLabel = isMockMode ? '‚úÖ On (safe testing)' : '‚úÖ On';
                        const offLabel = isMockMode ? '‚ö†Ô∏è Off (live operations)' : '‚ùå Off';

                        inputHtml = `
                            <select id="secret-${secret.name}" data-secret-name="${secret.name}" class="form-input" style="padding: 0.5rem;">
                                <option value="true" ${isTrue ? 'selected' : ''}>${onLabel}</option>
                                <option value="false" ${!isTrue ? 'selected' : ''}>${offLabel}</option>
                            </select>`;
                    } else if (secret.name === 'MIRROR_RESET_MODE') {
                        const modeVal = localSet ? currentValue : 'isolated';
                        inputHtml = `
                            <select id="secret-${secret.name}" data-secret-name="${secret.name}" class="form-input" style="padding: 0.5rem;">
                                <option value="isolated" ${modeVal === 'isolated' ? 'selected' : ''}>üîí Isolated (no cross-reset)</option>
                                <option value="leader" ${modeVal === 'leader' ? 'selected' : ''}>üëë Leader (push reset to mirrors)</option>
                                <option value="follower" ${modeVal === 'follower' ? 'selected' : ''}>üì° Follower (accept reset from leader)</option>
                            </select>`;
                    } else {
                        const inputType = nonSensitive.includes(secret.name) ? 'text' : 'password';
                        const existingValue = nonSensitive.includes(secret.name) && localSet ? currentValue : '';
                        inputHtml = `
                            <input type="${inputType}" 
                                   id="secret-${secret.name}" 
                                   placeholder="${localSet && inputType === 'password' ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : 'Enter value...'}"
                                   value="${existingValue}"
                                   data-secret-name="${secret.name}">`;
                    }

                    // Move action button LEFT of input for select secrets
                    if (actionBtn && secret.name === 'CONTENT_ENCRYPTION_KEY') {
                        inputHtml = `<div style="display:flex;gap:0.35rem;align-items:center;">${actionBtn}${inputHtml}</div>`;
                        actionBtn = '';
                    }

                    const tier = getSecretTier(secret.name);
                    // Delete from GitHub ‚Äî for secrets or variables that are set
                    const canDeleteSecret = tier === 'secret' && ghSet;
                    const canDeleteVar = tier === 'var' && ghVariables.includes(secret.name);
                    const canDeleteGh = canDeleteSecret || canDeleteVar;
                    const deleteKind = tier === 'var' ? 'variable' : 'secret';

                    // Tier-based GitHub column
                    let ghColumn;
                    switch (tier) {
                        case 'auto':
                            ghColumn = `<div title="Automatically provided by GitHub Actions at runtime" style="color: var(--text-dim);">üîÑ Auto</div>`;
                            break;
                        case 'secret':
                            ghColumn = `<div title="GitHub Secret (used by Actions)">${ghSet ? '‚úÖ' : '‚ùå'} GitHub</div>`;
                            break;
                        case 'var':
                            const varSet = ghVariables.includes(secret.name);
                            ghColumn = `<div title="GitHub repo variable (vars.*). Pushed via gh variable set.">${varSet ? '‚úÖ' : '‚ùå'} Var</div>`;
                            break;
                        default:
                            ghColumn = `<div title="Local only ‚Äî not used in GitHub workflows" style="color: var(--text-dim);">üìÅ Local only</div>`;
                    }

                    html += `
                        <div class="secret-config-row" style="display: grid; grid-template-columns: 1fr 1.5fr auto 110px 110px; gap: 0.5rem; align-items: center;">
                            <div class="secret-config-name" translate="no">
                                ${secret.name}
                                ${isRequired ? '<span style="color: var(--danger);">*</span>' : ''}
                            </div>
                            <div class="secret-config-value">
                                ${inputHtml}
                            </div>
                            <div>${actionBtn}</div>
                            <div class="secret-config-status" style="text-align: center; font-size: 0.8rem; display: flex; align-items: center; gap: 0.25rem; justify-content: center;">
                                <div title="Local (.env)">${localSet ? '‚úÖ' : '‚ùå'} Local</div>
                                ${localSet ? `<button class="btn" onclick="markForDeletion('${secret.name}')" style="padding:0.15rem 0.35rem;font-size:0.7rem;" title="Mark ${secret.name} for deletion from local .env (applied on Save)">üóëÔ∏è</button>` : ''}
                            </div>
                            <div class="secret-config-status" style="text-align: center; font-size: 0.8rem; display: flex; align-items: center; gap: 0.25rem; justify-content: center;">
                                ${ghColumn}
                                ${canDeleteGh ? `<button class="btn" onclick="removeSecret('${secret.name}','github','${deleteKind}')" style="padding:0.15rem 0.35rem;font-size:0.7rem;" title="Remove ${secret.name} from GitHub">üóëÔ∏è</button>` : ''}
                            </div>
                        </div>
                    `;
                }
            }

            // CONTINUITY_CONFIG master secret panel ‚Äî always shown
            const ghMasterSet = ghSecrets.includes('CONTINUITY_CONFIG');

            // Compute pending sync counts for Save & Push badge
            let pendingSecrets = 0;
            let pendingVars = 0;
            for (const name of GITHUB_SECRETS) {
                if (AUTO_PROVIDED.includes(name) || name === 'CONTINUITY_CONFIG') continue;
                const localVal = envData[name];
                if (localVal && !ghSecrets.includes(name)) pendingSecrets++;
            }
            for (const name of GITHUB_VARS) {
                const localVal = envData[name];
                if (localVal && !ghVariables.includes(name)) pendingVars++;
            }
            const totalPending = pendingSecrets + pendingVars;

            // Master config: count how many adapter credentials have values
            const masterConfig = buildMasterConfigJson();
            const masterKeyCount = Object.keys(masterConfig).length;

            html += `
                <div id="master-secret-panel" style="margin-top: 1.5rem; padding: 1rem; border: 2px solid ${ghMasterSet ? 'var(--warning)' : 'var(--border)'}; border-radius: 8px; background: ${ghMasterSet ? 'rgba(255,193,7,0.08)' : 'transparent'};">
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; flex-wrap: wrap;">
                        <strong style="font-size: 1rem;">üîë Master Secret: <code>CONTINUITY_CONFIG</code></strong>
                        <span style="font-size: 0.75rem; padding: 0.1rem 0.5rem; border-radius: 4px; background: ${ghMasterSet ? 'var(--warning)' : 'var(--bg-input)'}; color: ${ghMasterSet ? '#000' : 'var(--text-dim)'};">
                            ${ghMasterSet ? '‚úÖ SET ON GITHUB' : 'NOT SET'}
                        </span>
                        <span id="master-status-badge" style="font-size: 0.75rem; padding: 0.1rem 0.5rem; border-radius: 4px; display: none; background: var(--danger); color: #fff;"></span>
                        ${!ghMasterSet ? '<span style="font-size: 0.75rem; color: var(--text-dim); font-style: italic;">(optional ‚Äî individual secrets work fine without it)</span>' : ''}
                    </div>
                    <div style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.75rem;">
                        ${ghMasterSet
                    ? `<strong style="color: var(--warning);">‚ö†Ô∏è Active ‚Äî complete override, not a merge.</strong>
                               Only secrets present in your local <code>.env</code> are included.
                               If a secret is missing locally, it will be <strong>absent from CI</strong> ‚Äî even if it was pushed individually before.<br>
                               Does not include GitHub Variables (${GITHUB_VARS.join(', ')}).<br>
                               <em>After modifying secrets above, re-generate and push to keep the master in sync.</em>`
                    : `Bundles your local <code>.env</code> secrets into a single GitHub secret.<br>
                               <strong>‚ö†Ô∏è Complete override</strong> ‚Äî only secrets present locally are included. Missing secrets = absent from CI.<br>
                               <strong>Not required</strong> ‚Äî you can push secrets individually instead.
                               <em>Useful if you prefer one secret over many.</em>`
                }
                    </div>
                    <div style="display: flex; gap: 0.5rem; align-items: center; font-size: 0.85rem; flex-wrap: wrap;">
                        <button class="btn" id="master-preview-btn" onclick="generateMasterSecret()" style="padding:0.3rem 0.75rem;font-size:0.8rem;" ${masterKeyCount === 0 ? 'disabled title="No credentials configured yet"' : `title="Preview the ${masterKeyCount} credentials that would be bundled into CONTINUITY_CONFIG"`}>üìã Preview JSON (<span id="master-key-count">${masterKeyCount} keys</span>)</button>
                        <button class="btn primary" id="master-push-btn" onclick="pushMasterSecret()" style="padding:0.3rem 0.75rem;font-size:0.8rem;" ${masterKeyCount === 0 ? 'disabled title="No credentials to push"' : `title="Push ${masterKeyCount} credentials as CONTINUITY_CONFIG to GitHub (does not save to local .env)"`}>‚òÅÔ∏è Push to GitHub</button>
                        ${ghMasterSet ? `<button class="btn" id="master-remove-btn" onclick="removeSecret('CONTINUITY_CONFIG','github')" style="padding:0.3rem 0.75rem;font-size:0.8rem;" title="Remove CONTINUITY_CONFIG from GitHub">üóëÔ∏è Remove from GitHub</button>` : ''}
                    </div>
                </div>
            `;

            html += `
                <!-- Save Section -->
                <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                    <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
                        <label style="color: var(--text-dim);">Save to:</label>
                        <div style="display: flex; border: 1px solid var(--border); border-radius: 8px; overflow: hidden;">
                            <button type="button" class="target-btn active" data-target="both" onclick="selectTarget('both')">Both</button>
                            <button type="button" class="target-btn" data-target="local" onclick="selectTarget('local')">Local Only</button>
                            <button type="button" class="target-btn" data-target="github" onclick="selectTarget('github')">GitHub Only</button>
                        </div>
                        <button class="btn primary" id="save-secrets-btn" onclick="pushSecrets(currentTarget)" disabled>üíæ Save & Push</button>
                        <span id="sync-pending-badge" style="font-size: 0.8rem; color: var(--warning); ${totalPending > 0 ? '' : 'display:none;'}"></span>
                    </div>
                    <div style="margin-top: 0.75rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.85rem;">
                            <input type="checkbox" id="secrets-git-sync" ${gitTool?.installed ? 'checked' : 'disabled'}>
                            <span style="color: var(--text-dim);">üîÑ Git sync after save (commit & push all changes)</span>
                            ${!gitTool?.installed ? '<span style="color: var(--warning); font-size: 0.8rem;">‚ö†Ô∏è git not found</span>' : ''}
                        </label>
                    </div>
                </div>

                <!-- Manage Section -->
                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                    <div style="font-size: 0.85rem; font-weight: 600; color: var(--text-dim); margin-bottom: 0.75rem;">üõ†Ô∏è Manage</div>
                    <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
                        <button class="btn" onclick="syncEnvToGithub()" title="Force re-push all .env values to GitHub (secrets + variables)">‚òÅÔ∏è Sync .env ‚Üí GitHub</button>
                        <button class="btn" onclick="clearSecretsPrompt('local')" title="Clear all local .env secret values" style="color: var(--warning);">üóëÔ∏è Clear Local Secrets</button>
                        <button class="btn" onclick="clearSecretsPrompt('github')" title="Remove all GitHub secrets" style="color: var(--danger);">üóëÔ∏è Clear GitHub Secrets</button>
                    </div>
                </div>
                <style>
                    .target-btn { padding: 0.5rem 1rem; border: none; background: var(--bg-input); color: var(--text-dim); cursor: pointer; transition: all 0.2s; }
                    .target-btn:hover { background: var(--bg-card); }
                    .target-btn.active { background: var(--accent); color: white; }
                </style>
            `;

            document.getElementById('secrets-form').innerHTML = html;

            // Snapshot initial values for dirty tracking
            secretsInitialValues = {};
            document.querySelectorAll('#secrets-form [data-secret-name]').forEach(el => {
                secretsInitialValues[el.dataset.secretName] = el.value;
            });
            secretsDirty = false;
            secretsLoaded = true;

            // Listen for changes ‚Äî also un-marks deletion when user types
            document.getElementById('secrets-form').addEventListener('input', (e) => {
                if (e.target.dataset && e.target.dataset.secretName && e.target.dataset.markedDelete) {
                    // User started typing in a field marked for deletion ‚Üí un-mark it
                    unmarkDeletion(e.target.dataset.secretName);
                }
                checkSecretsDirty();
            });
            document.getElementById('secrets-form').addEventListener('change', (e) => {
                if (e.target.dataset && e.target.dataset.secretName && e.target.dataset.markedDelete) {
                    unmarkDeletion(e.target.dataset.secretName);
                }
                checkSecretsDirty();
            });

            // Run initial state evaluation (enable/disable Save button, set badges)
            checkSecretsDirty();
        }

        let secretsInitialValues = {};
        let secretsDirty = false;
        let secretsLoaded = false;

        function checkSecretsDirty() {
            const fields = document.querySelectorAll('#secrets-form [data-secret-name]');
            let changed = 0;
            let changedNames = [];
            let masterChanged = 0;
            let deletionCount = 0;
            fields.forEach(el => {
                const name = el.dataset.secretName;
                const isMarkedDelete = el.dataset.markedDelete === 'true';
                if (isMarkedDelete) {
                    changed++;
                    deletionCount++;
                    changedNames.push(name);
                    if (MASTER_CONFIG_ENVVARS.includes(name)) masterChanged++;
                } else if (el.value !== (secretsInitialValues[name] ?? '')) {
                    changed++;
                    changedNames.push(name);
                    if (MASTER_CONFIG_ENVVARS.includes(name)) masterChanged++;
                }
            });
            secretsDirty = changed > 0;

            // --- Save & Push button: enable/disable ---
            const saveBtn = document.getElementById('save-secrets-btn');

            // Count unsynced secrets (local .env ‚Üí GitHub)
            let unsyncedSecrets = 0;
            let unsyncedVars = 0;
            for (const name of GITHUB_SECRETS) {
                if (AUTO_PROVIDED.includes(name) || name === 'CONTINUITY_CONFIG') continue;
                if (envData[name] && !ghSecrets.includes(name)) unsyncedSecrets++;
            }
            for (const name of GITHUB_VARS) {
                if (envData[name] && !ghVariables.includes(name)) unsyncedVars++;
            }
            // Count form changes that are NEW pushable items (not already counted as unsynced)
            let newFormChanges = 0;
            for (const name of changedNames) {
                const tier = getSecretTier(name);
                if (tier === 'auto') continue;
                const alreadyCounted = (tier === 'secret' && !ghSecrets.includes(name) && envData[name])
                    || (tier === 'var' && !ghVariables.includes(name) && envData[name]);
                if (!alreadyCounted) newFormChanges++;
            }

            const totalActionable = unsyncedSecrets + unsyncedVars + newFormChanges;
            const hasAnythingToDo = changed > 0 || totalActionable > 0;

            if (saveBtn) {
                saveBtn.disabled = !hasAnythingToDo;
                if (saveBtn.disabled) {
                    saveBtn.title = 'No changes to save and all values are synced to GitHub';
                } else {
                    saveBtn.title = '';
                }
            }

            // --- Pending badge: precise message ---
            const badge = document.getElementById('sync-pending-badge');
            if (badge) {
                const parts = [];
                if (unsyncedSecrets > 0) parts.push(`${unsyncedSecrets} secret(s) local only ‚Äî not yet on GitHub`);
                if (unsyncedVars > 0) parts.push(`${unsyncedVars} variable(s) local only ‚Äî not yet on GitHub`);
                if (deletionCount > 0) parts.push(`${deletionCount} marked for deletion`);
                if (changed > 0 && deletionCount < changed) {
                    const modified = changed - deletionCount;
                    if (modified > 0) parts.push(`${modified} value(s) modified`);
                }

                if (parts.length > 0) {
                    badge.textContent = '‚ö†Ô∏è ' + parts.join(' ¬∑ ');
                    badge.title = parts.join('\n');
                    badge.style.display = '';
                } else {
                    badge.style.display = 'none';
                }
            }

            // --- Master secret: outdated detection + key count ---
            const masterStatusBadge = document.getElementById('master-status-badge');
            const masterBadge = document.getElementById('master-key-count');
            const ghMasterIsSet = ghSecrets.includes('CONTINUITY_CONFIG');

            if (masterBadge) {
                // Merge live form values on top of envData for key count
                const liveEnv = { ...envData };
                fields.forEach(el => {
                    if (el.value) liveEnv[el.dataset.secretName] = el.value;
                });
                const oldEnvData = envData;
                envData = liveEnv;
                const config = buildMasterConfigJson();
                envData = oldEnvData;
                const count = Object.keys(config).length;
                masterBadge.textContent = `${count} keys`;
            }

            if (masterStatusBadge) {
                if (ghMasterIsSet && masterChanged > 0) {
                    masterStatusBadge.textContent = `‚ö†Ô∏è OUTDATED ‚Äî ${masterChanged} secret(s) changed since last push`;
                    masterStatusBadge.style.display = '';
                } else {
                    masterStatusBadge.style.display = 'none';
                }
            }
        }

        function markForDeletion(name) {
            const input = document.querySelector(`[data-secret-name="${name}"]`);
            if (!input) return;
            input.dataset.markedDelete = 'true';
            input.value = '';
            input.disabled = true;
            input.placeholder = 'üóëÔ∏è Will be deleted on Save';
            input.style.borderColor = 'var(--danger)';
            input.style.opacity = '0.5';

            const row = input.closest('.secret-config-row');
            if (row) {
                // Strikethrough the name
                const nameEl = row.querySelector('.secret-config-name');
                if (nameEl) nameEl.style.textDecoration = 'line-through';
                // Replace the local delete button with an undo button
                const localStatus = row.querySelectorAll('.secret-config-status')[0];
                if (localStatus) {
                    localStatus.innerHTML = `
                        <div title="Marked for deletion" style="color: var(--danger);">üóëÔ∏è Delete</div>
                        <button class="btn" onclick="unmarkDeletion('${name}')" style="padding:0.15rem 0.35rem;font-size:0.7rem;" title="Undo: keep ${name} in local .env">‚Ü©Ô∏è</button>
                    `;
                }
            }
            checkSecretsDirty();
        }

        function unmarkDeletion(name) {
            const input = document.querySelector(`[data-secret-name="${name}"]`);
            if (!input) return;
            delete input.dataset.markedDelete;
            input.disabled = false;
            input.style.borderColor = '';
            input.style.opacity = '';
            // Restore original placeholder and value
            const localSet = envData[name] && envData[name].length > 0;
            const nonSensitive = ['GITHUB_REPOSITORY', 'OPERATOR_EMAIL', 'RESEND_FROM_EMAIL',
                'TWILIO_FROM_NUMBER', 'OPERATOR_SMS', 'PROJECT_NAME',
                'REDDIT_USERNAME', 'TWILIO_ACCOUNT_SID', 'REDDIT_CLIENT_ID',
                'ARCHIVE_URL', 'WEBHOOK_TIMEOUT', 'DEPLOY_MODE',
                'PERSISTENCE_API_URL'];
            const isSensitive = !nonSensitive.includes(name);
            input.placeholder = localSet && isSensitive ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : 'Enter value...';
            if (!isSensitive && localSet) input.value = envData[name];

            const row = input.closest('.secret-config-row');
            if (row) {
                const nameEl = row.querySelector('.secret-config-name');
                if (nameEl) nameEl.style.textDecoration = '';
                // Restore local status with delete button
                const localStatus = row.querySelectorAll('.secret-config-status')[0];
                if (localStatus) {
                    localStatus.innerHTML = `
                        <div title="Local (.env)">${localSet ? '‚úÖ' : '‚ùå'} Local</div>
                        ${localSet ? `<button class="btn" onclick="markForDeletion('${name}')" style="padding:0.15rem 0.35rem;font-size:0.7rem;" title="Mark ${name} for deletion from local .env (applied on Save)">üóëÔ∏è</button>` : ''}
                    `;
                }
            }
            checkSecretsDirty();
        }

        function refreshSecrets() {
            if (secretsDirty) {
                if (!confirm('You have unsaved secret changes. Refresh anyway?')) return;
            }
            // Show loading state (same as initial page load)
            document.getElementById('secrets-form').innerHTML = '<div class="loading">Loading secrets</div>';
            secretsLoaded = false;
            // Force fresh data fetch
            appData = null;
            loadSecretsForm();
        }

        function buildMasterConfigJson() {
            // Build the master config JSON from current .env values
            // Mirrors the fields in loader.py's _parse_master_config
            const fields = {
                // Project / operator info (needed by tick but not passed individually in workflow)
                project_name: envData['PROJECT_NAME'] || '',
                operator_email: envData['OPERATOR_EMAIL'] || '',
                operator_sms: envData['OPERATOR_SMS'] || '',
                // Email (Resend)
                resend_api_key: envData['RESEND_API_KEY'] || '',
                resend_from_email: envData['RESEND_FROM_EMAIL'] || '',
                // SMS (Twilio)
                twilio_account_sid: envData['TWILIO_ACCOUNT_SID'] || '',
                twilio_auth_token: envData['TWILIO_AUTH_TOKEN'] || '',
                twilio_from_number: envData['TWILIO_FROM_NUMBER'] || '',
                // X (Twitter)
                x_api_key: envData['X_API_KEY'] || '',
                x_api_secret: envData['X_API_SECRET'] || '',
                x_access_token: envData['X_ACCESS_TOKEN'] || '',
                x_access_secret: envData['X_ACCESS_SECRET'] || '',
                // Reddit
                reddit_client_id: envData['REDDIT_CLIENT_ID'] || '',
                reddit_client_secret: envData['REDDIT_CLIENT_SECRET'] || '',
                reddit_username: envData['REDDIT_USERNAME'] || '',
                reddit_password: envData['REDDIT_PASSWORD'] || '',
                // NOT github_token/github_repository ‚Äî auto-provided by GitHub Actions at runtime.
                // Including them would override CI values with your local gh token.
                // Persistence
                persistence_api_url: envData['PERSISTENCE_API_URL'] || '',
                persistence_api_key: envData['PERSISTENCE_API_KEY'] || '',
                // Renewal / Security
                renewal_secret: envData['RENEWAL_SECRET'] || '',
                release_secret: envData['RELEASE_SECRET'] || '',
                renewal_trigger_token: envData['RENEWAL_TRIGGER_TOKEN'] || '',
                // Mirror
                mirror_1_token: envData['MIRROR_1_TOKEN'] || '',
                mirror_1_renewal_trigger_token: envData['MIRROR_1_RENEWAL_TRIGGER_TOKEN'] || '',
            };
            // Only include non-empty values
            const clean = {};
            for (const [k, v] of Object.entries(fields)) {
                if (v) clean[k] = v;
            }
            return clean;
        }

        function generateMasterSecret() {
            const config = buildMasterConfigJson();
            const json = JSON.stringify(config, null, 2);
            const count = Object.keys(config).length;

            const output = document.getElementById('secrets-output');
            const terminal = document.getElementById('secrets-terminal');
            output.style.display = 'block';
            terminal.className = 'terminal';
            terminal.textContent = `üìã CONTINUITY_CONFIG (${count} keys):\n\n${json}\n\nCopy this JSON and add it as a single GitHub secret named CONTINUITY_CONFIG.`;
        }

        async function pushMasterSecret() {
            // Merge live form values on top of envData so unsaved inputs are included
            const liveEnv = { ...envData };
            const fields = document.querySelectorAll('#secrets-form [data-secret-name]');
            const unsavedNames = [];
            fields.forEach(el => {
                const name = el.dataset.secretName;
                if (el.value && el.value !== (secretsInitialValues[name] ?? '')) {
                    liveEnv[name] = el.value;
                    unsavedNames.push(name);
                }
            });

            // Build config with live values
            const oldEnvData = envData;
            envData = liveEnv;
            const config = buildMasterConfigJson();
            envData = oldEnvData; // restore
            const count = Object.keys(config).length;

            if (count === 0) {
                alert('No adapter credentials found to bundle.\n\nSet some secrets above first.');
                return;
            }

            const json = JSON.stringify(config);

            // Warn about unsaved form values being included
            let confirmMsg = `Push CONTINUITY_CONFIG to GitHub with ${count} keys?\n`;
            confirmMsg += `\n‚ö†Ô∏è This is a COMPLETE OVERRIDE ‚Äî only secrets present here will exist in CI.`;
            confirmMsg += `\nMissing secrets will be absent, even if pushed individually before.`;
            if (unsavedNames.length > 0) {
                confirmMsg += `\n\nüìù Including ${unsavedNames.length} unsaved form value(s): ${unsavedNames.join(', ')}`;
                confirmMsg += `\n‚ö†Ô∏è These are NOT saved to .env yet ‚Äî click Save & Push after this to persist them locally.`;
            }
            if (!confirm(confirmMsg)) return;

            const output = document.getElementById('secrets-output');
            const terminal = document.getElementById('secrets-terminal');
            output.style.display = 'block';
            terminal.className = 'terminal';
            terminal.textContent = `‚òÅÔ∏è Pushing CONTINUITY_CONFIG (${count} keys) to GitHub...\n`;

            // Put master secret panel in loading state
            const masterBtn = document.getElementById('master-push-btn');
            if (masterBtn) { masterBtn.disabled = true; masterBtn.textContent = '‚è≥ Pushing...'; }

            try {
                const response = await fetch('/api/secrets/push', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        secrets: { CONTINUITY_CONFIG: json },
                        push_to_github: true,
                        save_to_env: false,
                    }),
                });
                const data = await response.json();

                if (data.error) {
                    terminal.className = 'terminal error';
                    terminal.textContent += `‚ùå ${data.error}\n`;
                    // Restore button
                    if (masterBtn) { masterBtn.disabled = false; masterBtn.textContent = '‚òÅÔ∏è Push to GitHub'; }
                    return;
                }

                const r = (data.results || [])[0];
                if (r?.success) {
                    terminal.textContent += `‚úÖ CONTINUITY_CONFIG pushed to GitHub!\n\n${count} adapter credentials bundled into one secret.`;
                    if (unsavedNames.length > 0) {
                        terminal.textContent += `\n\n‚ö†Ô∏è Remember: ${unsavedNames.join(', ')} are in the master but NOT saved to .env yet.`;
                        terminal.textContent += `\nClick Save & Push to persist them locally and push individually.`;
                    }
                } else {
                    terminal.className = 'terminal error';
                    terminal.textContent += `‚ùå Failed: ${r?.error || 'unknown'}\n`;
                }

                // Only refresh the master panel status (not the whole form, to preserve unsaved inputs)
                // Update ghSecrets to include CONTINUITY_CONFIG
                if (r?.success && !ghSecrets.includes('CONTINUITY_CONFIG')) {
                    ghSecrets.push('CONTINUITY_CONFIG');
                }
                // Restore button state
                if (masterBtn) { masterBtn.disabled = false; masterBtn.textContent = '‚òÅÔ∏è Push to GitHub'; }
                // Update the master status badge
                const masterStatusBadge = document.getElementById('master-status-badge');
                if (masterStatusBadge) masterStatusBadge.style.display = 'none';
            } catch (error) {
                terminal.className = 'terminal error';
                terminal.textContent += `‚ùå Error: ${error.message}`;
                if (masterBtn) { masterBtn.disabled = false; masterBtn.textContent = '‚òÅÔ∏è Push to GitHub'; }
            }
        }



        async function syncEnvToGithub() {
            if (!envData || Object.keys(envData).length === 0) {
                alert('No local .env values found.');
                return;
            }

            // Collect tier-1 secrets (excluding CONTINUITY_CONFIG ‚Äî handled separately)
            const secrets = {};
            for (const name of GITHUB_SECRETS) {
                const val = envData[name];
                if (val && name !== 'CONTINUITY_CONFIG') {
                    secrets[name] = val;
                }
            }

            // Collect tier-2 variables
            const variables = {};
            for (const name of GITHUB_VARS) {
                const val = envData[name];
                if (val) {
                    variables[name] = val;
                }
            }

            const secretCount = Object.keys(secrets).length;
            const varCount = Object.keys(variables).length;
            const totalCount = secretCount + varCount;
            if (totalCount === 0) {
                alert('No GitHub secrets or variables with values in .env to sync.');
                return;
            }

            let confirmMsg = `Push ${totalCount} value(s) from .env ‚Üí GitHub?\n\n`;
            if (secretCount) confirmMsg += `Secrets (${secretCount}): ${Object.keys(secrets).join(', ')}\n`;
            if (varCount) confirmMsg += `Variables (${varCount}): ${Object.keys(variables).join(', ')}\n`;
            confirmMsg += `\nThis will overwrite any existing GitHub values.`;

            if (!confirm(confirmMsg)) {
                return;
            }

            const output = document.getElementById('secrets-output');
            const terminal = document.getElementById('secrets-terminal');
            output.style.display = 'block';
            terminal.className = 'terminal';
            terminal.textContent = `‚òÅÔ∏è Syncing ${totalCount} value(s) from .env ‚Üí GitHub...\n`;

            try {
                const response = await fetch('/api/secrets/push', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        secrets,
                        variables,
                        push_to_github: true,
                        save_to_env: false,
                    }),
                });
                const data = await response.json();

                if (data.error) {
                    terminal.className = 'terminal error';
                    terminal.textContent = `Error: ${data.error}\n`;
                    return;
                }

                let text = '';
                let ok = 0, fail = 0;
                for (const r of (data.results || [])) {
                    const icon = r.kind === 'variable' ? 'üìã' : '‚òÅÔ∏è';
                    if (r.success) {
                        text += `${icon} ${r.name}\n`;
                        ok++;
                    } else {
                        text += `‚ùå ${r.name}: ${r.error}\n`;
                        fail++;
                    }
                }

                terminal.textContent = `‚òÅÔ∏è Sync complete: ${ok} pushed${fail ? `, ${fail} failed` : ''}\n\n${text}`;
                terminal.className = fail ? 'terminal error' : 'terminal';

                // Refresh to update GitHub column status
                secretsLoaded = false;
                appData = null;
                await loadSecretsForm();
                selectTarget(currentTarget);
            } catch (error) {
                terminal.className = 'terminal error';
                terminal.textContent = `‚ùå Error: ${error.message}`;
            }
        }

        async function removeSecret(name, target, kind = 'secret') {
            const label = target === 'local' ? 'local .env' : target === 'github' ? 'GitHub' : 'local & GitHub';
            if (!confirm(`Remove ${name} from ${label}?\n\nThis cannot be undone.`)) return;

            // Put affected row or master panel in loading state
            const rowInput = document.querySelector(`[data-secret-name="${name}"]`);
            if (rowInput) {
                const rowEl = rowInput.closest('.secret-config-row');
                if (rowEl) { rowEl.style.opacity = '0.5'; rowEl.style.pointerEvents = 'none'; }
            }
            // Handle master secret panel separately (CONTINUITY_CONFIG has no regular row)
            if (name === 'CONTINUITY_CONFIG') {
                const panel = document.getElementById('master-secret-panel');
                if (panel) { panel.style.opacity = '0.5'; panel.style.pointerEvents = 'none'; }
            }

            const output = document.getElementById('secrets-output');
            const terminal = document.getElementById('secrets-terminal');
            output.style.display = 'block';
            terminal.className = 'terminal';
            terminal.textContent = `üóëÔ∏è Removing ${name} from ${label}...\n`;

            try {
                const response = await fetch('/api/secret/remove', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, target, kind }),
                });
                const data = await response.json();

                let text = `üóëÔ∏è ${name}:\n`;
                if (data.local) text += `  Local: ${data.local.success ? '‚úÖ removed' : '‚ùå ' + data.local.error}\n`;
                if (data.github) text += `  GitHub: ${data.github.success ? '‚úÖ removed' : '‚ùå ' + data.github.error}\n`;
                terminal.textContent = text;

                // Refresh
                secretsLoaded = false;
                appData = null;
                await loadSecretsForm();
                selectTarget(currentTarget);
            } catch (error) {
                terminal.className = 'terminal error';
                terminal.textContent = `‚ùå Error: ${error.message}`;
            }
        }

        async function clearSecretsPrompt(target) {
            const label = target === 'local' ? 'local .env' : 'GitHub';
            const secretsToRemove = target === 'local'
                ? KNOWN_SECRETS.filter(n => envData[n] && !AUTO_PROVIDED.includes(n))
                : ghSecrets.filter(n => GITHUB_SECRETS.includes(n));

            if (secretsToRemove.length === 0) {
                alert(`No secrets to clear from ${label}.`);
                return;
            }

            if (!confirm(`‚ö†Ô∏è DANGER: Remove ${secretsToRemove.length} secrets from ${label}?\n\n${secretsToRemove.join(', ')}\n\nThis cannot be undone!`)) return;
            if (!confirm(`Are you absolutely sure? This will delete all secret values from ${label}.`)) return;

            const output = document.getElementById('secrets-output');
            const terminal = document.getElementById('secrets-terminal');
            output.style.display = 'block';
            terminal.className = 'terminal';
            terminal.textContent = `üóëÔ∏è Clearing ${secretsToRemove.length} secrets from ${label}...\n`;

            let ok = 0, fail = 0;
            for (const name of secretsToRemove) {
                try {
                    const response = await fetch('/api/secret/remove', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, target }),
                    });
                    const data = await response.json();
                    const result = target === 'local' ? data.local : data.github;
                    if (result?.success) {
                        terminal.textContent += `‚úÖ ${name}\n`;
                        ok++;
                    } else {
                        terminal.textContent += `‚ùå ${name}: ${result?.error || 'unknown'}\n`;
                        fail++;
                    }
                } catch (e) {
                    terminal.textContent += `‚ùå ${name}: ${e.message}\n`;
                    fail++;
                }
            }

            terminal.textContent += `\nüóëÔ∏è Done: ${ok} removed${fail ? `, ${fail} failed` : ''}`;
            terminal.className = fail ? 'terminal error' : 'terminal';

            // Refresh
            secretsLoaded = false;
            appData = null;
            loadSecretsForm();
        }
        async function pushSecrets(target = 'both') {
            const inputs = document.querySelectorAll('[data-secret-name]');
            const gitSyncChecked = document.getElementById('secrets-git-sync')?.checked ?? false;

            // Only collect fields that were actually changed or marked for deletion
            const secrets = {};
            const deletions = [];
            inputs.forEach(input => {
                const name = input.dataset.secretName;
                const initial = secretsInitialValues[name] ?? '';
                if (input.dataset.markedDelete === 'true') {
                    deletions.push(name);
                } else if (input.value && input.value !== initial) {
                    secrets[name] = input.value;
                }
            });

            // When saving to Both: also include secrets/vars that exist locally but are missing from GitHub
            // Skip anything marked for deletion ‚Äî those should NOT be pushed
            if (target === 'both') {
                for (const name of GITHUB_SECRETS) {
                    if (secrets[name]) continue; // already changed
                    if (deletions.includes(name)) continue; // marked for deletion
                    if (AUTO_PROVIDED.includes(name)) continue;
                    const localVal = envData[name];
                    if (localVal && !ghSecrets.includes(name)) {
                        secrets[name] = localVal;
                    }
                }
                for (const name of GITHUB_VARS) {
                    if (secrets[name]) continue;
                    if (deletions.includes(name)) continue; // marked for deletion
                    const localVal = envData[name];
                    if (localVal && !ghVariables.includes(name)) {
                        secrets[name] = localVal;
                    }
                }
            }

            if (Object.keys(secrets).length === 0 && deletions.length === 0) {
                // Should not happen since the button is disabled, but safety check
                return;
            }

            // Split changed values into secrets vs variables for the correct gh command
            const ghPush = target === 'both' || target === 'github';
            const secretsForGh = {};
            const variablesForGh = {};
            if (ghPush) {
                for (const [k, v] of Object.entries(secrets)) {
                    if (AUTO_PROVIDED.includes(k)) continue;
                    if (GITHUB_VARS.includes(k)) {
                        variablesForGh[k] = v;
                    } else if (GITHUB_SECRETS.includes(k)) {
                        secretsForGh[k] = v;
                    }
                    // LOCAL_ONLY values are not pushed to GitHub at all
                }
            }

            const output = document.getElementById('secrets-output');
            const terminal = document.getElementById('secrets-terminal');

            const actionCount = Object.keys(secrets).length + deletions.length;
            const targetLabel = target === 'both' ? 'local & GitHub' : target;
            output.style.display = 'block';
            terminal.className = 'terminal';
            terminal.textContent = `Saving ${actionCount} change(s) to ${targetLabel}...\n`;

            // Put affected rows in loading state
            for (const name of [...Object.keys(secrets), ...deletions]) {
                const row = document.querySelector(`[data-secret-name="${name}"]`);
                if (row) {
                    const rowEl = row.closest('.secret-config-row');
                    if (rowEl) { rowEl.style.opacity = '0.5'; rowEl.style.pointerEvents = 'none'; }
                }
            }

            try {
                const response = await fetch('/api/secrets/push', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        secrets: secretsForGh,
                        variables: variablesForGh,
                        env_values: (target === 'both' || target === 'local') ? secrets : {},
                        deletions: (target === 'both' || target === 'local') ? deletions : [],
                        push_to_github: ghPush,
                        save_to_env: target === 'both' || target === 'local',
                        exclude_from_github: AUTO_PROVIDED,
                    }),
                });
                const data = await response.json();

                if (data.error) {
                    terminal.className = 'terminal error';
                    terminal.textContent = `Error: ${data.error}\n`;
                    if (data.install_hint) {
                        terminal.textContent += `\n${data.install_hint}`;
                    }
                    return;
                }

                let output_text = '';

                // Show env save status
                if (data.env_saved) {
                    const savedKeys = Object.keys(secrets);
                    if (savedKeys.length > 0) output_text += `üìÅ Saved to .env: ${savedKeys.join(', ')}\n`;
                    if (data.deletions_applied && data.deletions_applied.length > 0) {
                        output_text += `üóëÔ∏è Deleted from .env: ${data.deletions_applied.join(', ')}\n`;
                    }
                }

                // Show GitHub push results (secrets + variables)
                for (const result of (data.results || [])) {
                    const icon = result.kind === 'variable' ? 'üìã' : '‚òÅÔ∏è';
                    const label = result.kind === 'variable' ? 'variable' : 'secret';
                    if (result.success) {
                        output_text += `${icon} ${result.name}: pushed as GitHub ${label}\n`;
                    } else {
                        output_text += `‚ùå ${result.name}: ${result.error}\n`;
                    }
                }

                terminal.textContent = output_text || 'Done!';
                terminal.className = data.all_success !== false ? 'terminal' : 'terminal error';

                // Git sync if requested
                if (gitSyncChecked) {
                    terminal.textContent += `\nüîÑ Syncing to Git...\n`;
                    try {
                        const syncResponse = await fetch('/api/git/sync', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: 'chore: secrets update from admin panel' }),
                        });
                        const syncData = await syncResponse.json();
                        if (syncData.success) {
                            terminal.textContent += `üîÑ ${syncData.message}\n`;
                        } else {
                            terminal.textContent += `‚ö†Ô∏è Git sync: ${syncData.error || 'failed'}\n`;
                            if (syncData.hint) terminal.textContent += `   üí° ${syncData.hint}\n`;
                        }
                    } catch (e) {
                        terminal.textContent += `‚ö†Ô∏è Git sync failed: ${e.message}\n`;
                    }
                }

                // Smooth refresh: show loading overlay, then rebuild form with fresh data
                if (data.all_success !== false) {
                    // Show loading overlay on the form (no input clearing = no flash)
                    const formEl = document.getElementById('secrets-form');
                    formEl.style.position = 'relative';
                    const overlay = document.createElement('div');
                    overlay.id = 'secrets-loading-overlay';
                    overlay.style.cssText = 'position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;border-radius:8px;z-index:10;';
                    overlay.innerHTML = '<div style="color:#fff;font-size:1rem;">üîÑ Refreshing‚Ä¶</div>';
                    formEl.appendChild(overlay);

                    // Invalidate data and rebuild immediately
                    secretsLoaded = false;
                    appData = null;
                    await loadSecretsForm();
                    // Re-apply target selection so button state persists
                    selectTarget(currentTarget);
                }
            } catch (error) {
                terminal.className = 'terminal error';
                terminal.textContent = `Error: ${error.message}`;
            }
        }


        async function generateContentKey() {
            try {
                const response = await fetch('/api/content/keygen', { method: 'POST' });
                const data = await response.json();
                if (data.error) { alert('Failed to generate key: ' + data.error); return; }
                const input = document.getElementById('secret-CONTENT_ENCRYPTION_KEY');
                if (input) {
                    input.type = 'text';
                    input.value = data.key;
                    input.style.borderColor = 'var(--accent)';
                    setTimeout(() => { input.style.borderColor = ''; }, 2000);
                    checkSecretsDirty();
                }
            } catch (error) {
                alert('Error generating key: ' + error.message);
            }
        }
