
// ========================================
// MEDIA MANAGEMENT (Content Tab â€” Media Mode)
// ========================================

let mediaLoaded = false;
let mediaEntries = [];
let mediaSelectedId = null;
let mediaPendingFile = null;
let contentCurrentMode = 'articles'; // 'articles', 'media', or 'messages'
let _mediaActiveXhr = null;  // reference to active upload XHR for cancel
let _mediaReleasePollInterval = null;  // release upload status polling
let _mediaReleaseMediaId = null;       // media ID of active release upload

function mediaCancelUploadInProgress() {
    if (_mediaActiveXhr) {
        _mediaActiveXhr.abort();
        _mediaActiveXhr = null;
    }
    if (window._mediaOptInterval) {
        clearInterval(window._mediaOptInterval);
        window._mediaOptInterval = null;
    }
    if (_mediaReleasePollInterval) {
        clearInterval(_mediaReleasePollInterval);
        _mediaReleasePollInterval = null;
    }
    // Kill backend ffmpeg process if actively encoding
    fetch('/api/content/media/cancel-optimize', { method: 'POST' })
        .then(r => r.json())
        .then(d => { if (d.message !== 'No active optimization') contentLog(`âš™ï¸ ${d.message}`); })
        .catch(() => {});
    // Cancel the backend release upload process if running
    if (_mediaReleaseMediaId) {
        fetch(`/api/content/media/${_mediaReleaseMediaId}/release-cancel`, { method: 'POST' })
            .then(r => r.json())
            .then(d => contentLog(`âš ï¸ Release upload cancelled: ${d.message}`))
            .catch(() => {});
        _mediaReleaseMediaId = null;
    }
    contentLog('âš ï¸ Upload cancelled by user');
    mediaUploadPrompt();
}

// â”€â”€ Mode switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function contentSwitchMode(mode) {
    if (mode === contentCurrentMode) return;

    // Warn if article editor is dirty
    if (contentCurrentMode === 'articles' && contentDirty) {
        if (!confirm('You have unsaved changes. Switch anyway?')) return;
    }

    // Warn if messages editor is dirty
    if (contentCurrentMode === 'messages' && typeof messagesDirty !== 'undefined' && messagesDirty) {
        if (!confirm('You have unsaved message changes. Switch anyway?')) return;
    }

    contentCurrentMode = mode;

    // Toggle sidebar sections
    document.getElementById('content-sidebar-articles').style.display = mode === 'articles' ? '' : 'none';
    document.getElementById('content-sidebar-media').style.display = mode === 'media' ? '' : 'none';
    document.getElementById('content-sidebar-messages').style.display = mode === 'messages' ? '' : 'none';

    // Toggle right panels
    document.getElementById('content-editor-card').style.display = mode === 'articles' ? 'flex' : 'none';
    document.getElementById('media-panel-card').style.display = mode === 'media' ? 'flex' : 'none';
    document.getElementById('messages-panel-card').style.display = mode === 'messages' ? 'flex' : 'none';

    // Toggle button active state
    document.getElementById('content-mode-articles').classList.toggle('active', mode === 'articles');
    document.getElementById('content-mode-media').classList.toggle('active', mode === 'media');
    document.getElementById('content-mode-messages').classList.toggle('active', mode === 'messages');

    // Load data on first switch
    if (mode === 'media' && !mediaLoaded) {
        loadMedia();
    }
    if (mode === 'messages' && typeof messagesLoaded !== 'undefined' && !messagesLoaded) {
        messagesLoad();
    }
}

// â”€â”€ Load media data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function loadMedia() {
    try {
        const resp = await fetch('/api/content/media');
        const data = await resp.json();
        mediaEntries = data.media || [];

        // Summary bar
        const summary = document.getElementById('media-summary');
        if (mediaEntries.length === 0) {
            summary.textContent = 'No media files uploaded yet';
        } else {
            const totalSize = formatMediaSize(data.total_size_bytes || 0);
            summary.textContent = `${mediaEntries.length} file${mediaEntries.length !== 1 ? 's' : ''} Â· ${totalSize} total`;
        }

        renderMediaGallery();
        mediaLoaded = true;
    } catch (error) {
        document.getElementById('media-gallery-list').innerHTML =
            `<div style="color: var(--danger); font-size: 0.85rem;">âŒ Failed to load: ${error.message}</div>`;
    }
}

// â”€â”€ Render media gallery â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderMediaGallery() {
    const el = document.getElementById('media-gallery-list');

    if (mediaEntries.length === 0) {
        el.innerHTML = `
            <div style="text-align: center; padding: 1.5rem 0; color: var(--text-dim);">
                <div style="font-size: 2rem; margin-bottom: 0.5rem; opacity: 0.3;">ğŸ–¼ï¸</div>
                <p style="font-size: 0.85rem;">No media files yet</p>
                <button class="btn primary" onclick="mediaUploadPrompt()" style="margin-top: 0.75rem; font-size: 0.82rem;">
                    ğŸ“¤ Upload your first file
                </button>
            </div>`;
        return;
    }

    let html = '<div class="media-gallery-grid">';
    for (const item of mediaEntries) {
        const isSelected = item.id === mediaSelectedId;
        const icon = getMediaIcon(item.mime_type);
        const stageColor = getStageColor(item.min_stage);
        const isImage = item.mime_type?.startsWith('image/');
        const thumbSrc = isImage ? `/api/content/media/${item.id}/preview` : '';

        html += `
        <div onclick="mediaSelectItem('${item.id}')"
            class="media-gallery-item ${isSelected ? 'selected' : ''}"
            title="${item.original_name}\n${item.mime_type} Â· ${formatMediaSize(item.size_bytes)}">
            <div class="media-gallery-thumb">
                ${isImage
                    ? `<img src="${thumbSrc}" alt="${item.original_name}" loading="lazy"
                        style="width: 100%; height: 100%; object-fit: cover;"
                        onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                       <div style="display: none; align-items: center; justify-content: center; width: 100%; height: 100%; font-size: 1.5rem; opacity: 0.4;">ğŸ”’</div>`
                    : `<div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; font-size: 1.8rem; opacity: 0.5;">${icon}</div>`
                }
            </div>
            <div class="media-gallery-label">
                <span class="media-gallery-name" translate="no">${item.original_name}</span>
                <span class="media-gallery-meta">
                    <span translate="no" style="background: ${stageColor}22; color: ${stageColor}; padding: 0.05rem 0.3rem; border-radius: 3px; font-size: 0.62rem; font-weight: 600;">${item.min_stage}</span>
                </span>
            </div>
        </div>`;
    }
    html += '</div>';
    el.innerHTML = html;
}

// â”€â”€ Select media item â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function mediaSelectItem(mediaId) {
    // Clean up any running release poll from a previous upload
    if (_mediaReleasePollInterval) {
        clearInterval(_mediaReleasePollInterval);
        _mediaReleasePollInterval = null;
    }
    mediaSelectedId = mediaId;
    renderMediaGallery();

    const item = mediaEntries.find(m => m.id === mediaId);
    if (!item) return;

    // Show detail view, hide upload zone
    document.getElementById('media-upload-zone').style.display = 'none';
    document.getElementById('media-upload-options').style.display = 'none';
    document.getElementById('media-detail-view').style.display = 'flex';

    // Update panel title
    document.getElementById('media-panel-name').textContent = item.original_name;

    // Badges
    const badges = document.getElementById('media-panel-badges');
    if (item.encrypted) {
        badges.innerHTML = `
            <span class="badge" style="font-size: 0.72rem; padding: 0.15rem 0.5rem; background: rgba(74, 222, 128, 0.15); color: var(--accent);">
                ğŸ”’ Encrypted
            </span>`;
    } else {
        badges.innerHTML = `
            <span class="badge" style="font-size: 0.72rem; padding: 0.15rem 0.5rem; background: rgba(160, 160, 160, 0.15); color: var(--text-dim);">
                ğŸ“„ Plaintext
            </span>`;
    }

    // URI
    document.getElementById('media-detail-uri').textContent = `media://${mediaId}`;

    // Info
    document.getElementById('media-detail-info').innerHTML = `
        ${item.mime_type} Â· ${formatMediaSize(item.size_bytes)}
        ${item.enc_file_exists ? '' : '<br><span style="color: var(--danger);">âš ï¸ File missing on disk</span>'}`;

    // Stage selector
    document.getElementById('media-detail-stage').value = item.min_stage;

    // Caption
    document.getElementById('media-detail-caption').value = item.caption || '';

    // References
    const refs = item.referenced_by || [];
    document.getElementById('media-detail-refs').textContent = refs.length > 0
        ? `Referenced by: ${refs.join(', ')}`
        : 'Not referenced by any article';

    // Encrypt/decrypt toggle button
    const toggleBtn = document.getElementById('media-toggle-encrypt-btn');
    if (item.encrypted) {
        toggleBtn.textContent = 'ğŸ”“ Decrypt';
        toggleBtn.title = 'Decrypt this media file (store as plaintext)';
    } else {
        toggleBtn.textContent = 'ğŸ”’ Encrypt';
        toggleBtn.title = 'Encrypt this media file';
    }

    // Preview
    const previewEl = document.getElementById('media-detail-preview');
    const isImage = item.mime_type?.startsWith('image/');
    const isVideo = item.mime_type?.startsWith('video/');
    const isAudio = item.mime_type?.startsWith('audio/');
    const previewUrl = `/api/content/media/${mediaId}/preview`;

    // Download button (always available)
    const dlBtn = document.getElementById('media-download-btn');
    if (dlBtn) {
        dlBtn.href = previewUrl;
        dlBtn.download = item.original_name || mediaId;
        dlBtn.style.display = '';
    }

    if (isImage) {
        previewEl.innerHTML = `<img src="${previewUrl}" alt="${item.original_name}"
            style="max-width: 100%; max-height: 350px; object-fit: contain; border-radius: 4px;"
            onerror="this.outerHTML='<div style=\\'text-align: center; color: var(--text-dim);\\'>ğŸ”’ Preview unavailable<br><span style=\\'font-size: 0.78rem;\\'>Encryption key may not be set</span></div>'">`;
    } else if (isVideo) {
        // Try browser auto-detection for ALL video types â€” don't set 'type' attribute.
        // Chrome/Edge can decode H.264 inside MKV containers via codec sniffing.
        // If the browser can't play it, the 'error' event fires and we show a download fallback.
        const videoId = `media-video-${mediaId}`;
        previewEl.innerHTML = `
            <video id="${videoId}" controls style="max-width: 100%; max-height: 350px; border-radius: 4px;">
                <source src="${previewUrl}">
            </video>
            <div id="${videoId}-fallback" style="display: none; text-align: center; padding: 1.5rem;">
                <div style="font-size: 2.5rem; margin-bottom: 0.5rem; opacity: 0.5;">ğŸ¬</div>
                <p style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0.75rem;">
                    Cannot play this format in browser. Download to play with VLC.
                </p>
                <a href="${previewUrl}" download="${item.original_name}"
                   class="btn" style="padding: 0.4rem 1.2rem; font-size: 0.85rem;">
                    â¬‡ï¸ Download (${formatMediaSize(item.size_bytes)})
                </a>
            </div>`;
        // If browser can't decode, hide video and show download fallback
        const videoEl = document.getElementById(videoId);
        if (videoEl) {
            videoEl.addEventListener('error', () => {
                videoEl.style.display = 'none';
                const fb = document.getElementById(`${videoId}-fallback`);
                if (fb) fb.style.display = 'block';
            }, true);  // capture phase to catch <source> errors
        }
    } else if (isAudio) {
        previewEl.innerHTML = `
            <div style="text-align: center; width: 100%; padding: 2rem;">
                <div style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.4;">ğŸµ</div>
                <audio controls style="width: 100%; max-width: 400px;">
                    <source src="${previewUrl}" type="${item.mime_type}">
                </audio>
            </div>`;
    } else {
        const icon = getMediaIcon(item.mime_type);
        previewEl.innerHTML = `
            <div style="text-align: center; color: var(--text-dim);">
                <div style="font-size: 3rem; margin-bottom: 0.75rem; opacity: 0.4;">${icon}</div>
                <p>${item.original_name}</p>
                <a href="${previewUrl}" target="_blank" class="btn" style="margin-top: 0.75rem; padding: 0.4rem 1rem; font-size: 0.82rem;">
                    ğŸ“¥ Download preview
                </a>
            </div>`;
    }
}

// â”€â”€ Upload flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function mediaUploadPrompt() {
    // Reset to upload view
    mediaSelectedId = null;
    mediaPendingFile = null;
    renderMediaGallery();

    document.getElementById('media-panel-name').textContent = 'Upload media';
    document.getElementById('media-panel-badges').innerHTML = '';
    const detailView = document.getElementById('media-detail-view');
    if (detailView) detailView.style.display = 'none';

    const uploadZone = document.getElementById('media-upload-zone');
    if (uploadZone) uploadZone.style.display = 'flex';

    const uploadOpts = document.getElementById('media-upload-options');
    if (uploadOpts) uploadOpts.style.display = 'none';

    const progressEl = document.getElementById('media-upload-progress');
    if (progressEl) progressEl.style.display = 'none';

    const encryptCb = document.getElementById('media-upload-encrypt');
    if (encryptCb) encryptCb.checked = false;

    // Rebuild dropzone content (mediaFileSelected replaces innerHTML, destroying the file input)
    const dropzone = document.getElementById('media-dropzone');
    if (dropzone) {
        dropzone.style.display = '';
        dropzone.innerHTML = `
            <div style="text-align: center;">
                <div style="font-size: 3rem; margin-bottom: 0.75rem; opacity: 0.4;">ğŸ“¤</div>
                <p style="font-size: 0.95rem; margin-bottom: 0.5rem;">Drop a file here, or click to upload</p>
                <p style="font-size: 0.78rem; color: var(--text-dim);">
                    Images, PDFs, video, audio â€” up to 1 GB
                </p>
                <input type="file" id="media-file-input" style="display: none;"
                    accept="image/*,video/*,audio/*,application/pdf,text/*,.json,.xml,.eml,.msg,.csv,.md,.zip,.gz,.tar,.7z,.mkv,.webm,.mov,.avi"
                    onchange="mediaFileSelected(event)">
                <button class="btn" onclick="document.getElementById('media-file-input').click()"
                    style="margin-top: 1rem; padding: 0.5rem 1.5rem;">
                    ğŸ“ Choose File
                </button>
            </div>`;
    }

    // Reset progress bar
    const bar = document.getElementById('media-progress-bar');
    if (bar) {
        bar.style.width = '0%';
        bar.style.background = 'linear-gradient(90deg, var(--accent), #60a5fa)';
    }
    // Reset stages
    ['media-stage-upload', 'media-stage-optimize', 'media-stage-release'].forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            el.style.opacity = '0.4';
            el.style.borderBottom = 'none';
            el.style.color = '';
        }
    });
}

function mediaFileSelected(event) {
    const file = event.target.files[0];
    if (!file) return;

    mediaPendingFile = file;

    // Show upload options
    document.getElementById('media-upload-options').style.display = '';
    document.getElementById('media-upload-file-info').textContent =
        `${file.name} Â· ${formatMediaSize(file.size)}`;

    // Update dropzone text
    const dropzone = document.getElementById('media-dropzone');
    dropzone.innerHTML = `
        <div style="text-align: center;">
            <div style="font-size: 3rem; margin-bottom: 0.75rem; opacity: 0.6;">${getMediaIcon(file.type)}</div>
            <p style="font-size: 0.95rem; margin-bottom: 0.25rem; font-weight: 500;">${file.name}</p>
            <p style="font-size: 0.78rem; color: var(--text-dim);">${file.type || 'Unknown type'} Â· ${formatMediaSize(file.size)}</p>
        </div>`;
}

function mediaCancelUpload() {
    mediaPendingFile = null;
    mediaUploadPrompt();
}

async function mediaDoUpload() {
    if (!mediaPendingFile) return;

    const btn = document.getElementById('media-upload-btn');
    btn.disabled = true;
    btn.textContent = 'â³ Uploading...';

    const formData = new FormData();
    formData.append('file', mediaPendingFile);
    formData.append('min_stage', document.getElementById('media-upload-stage').value);
    formData.append('caption', document.getElementById('media-upload-caption').value);
    formData.append('encrypt', document.getElementById('media-upload-encrypt').checked ? '1' : '0');

    const fileSize = mediaPendingFile.size;
    const isVideo = mediaPendingFile.type?.startsWith('video/');
    const isAudio = mediaPendingFile.type?.startsWith('audio/');
    const isImage = mediaPendingFile.type?.startsWith('image/');
    const isPdf = mediaPendingFile.type === 'application/pdf';
    const fileName = mediaPendingFile.name;
    const fileExt = fileName.split('.').pop()?.toLowerCase() || '';

    // Show progress UI, hide dropzone and options (NOT the upload zone itself â€” progress bar is inside it)
    document.getElementById('media-dropzone').style.display = 'none';
    document.getElementById('media-upload-options').style.display = 'none';
    const progressContainer = document.getElementById('media-upload-progress');
    progressContainer.style.display = '';

    const progressBar = document.getElementById('media-progress-bar');
    const stageLabel = document.getElementById('media-progress-stage-label');
    const progressDetail = document.getElementById('media-progress-detail');
    const progressEta = document.getElementById('media-progress-eta');
    const stageUpload = document.getElementById('media-stage-upload');
    const stageOptimize = document.getElementById('media-stage-optimize');
    const stageRelease = document.getElementById('media-stage-release');

    function setProgress(pct, label, detail, eta) {
        progressBar.style.width = pct + '%';
        if (label) stageLabel.textContent = label;
        if (detail) progressDetail.textContent = detail;
        progressEta.textContent = eta || '';
    }

    function activateStage(stage) {
        [stageUpload, stageOptimize, stageRelease].forEach(el => {
            el.style.opacity = '0.4';
            el.style.borderBottom = 'none';
        });
        stage.style.opacity = '1';
        stage.style.borderBottom = '2px solid var(--accent)';
    }

    function completeStage(stage) {
        stage.style.opacity = '1';
        stage.style.borderBottom = '2px solid var(--accent)';
        stage.style.color = 'var(--accent)';
    }

    // â”€â”€ Stage 1: Upload (real progress via XHR) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    activateStage(stageUpload);
    setProgress(0, `ğŸ“¤ Uploading ${fileName}...`, '0%');

    let uploadStartTime = Date.now();

    try {
        const response = await new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            _mediaActiveXhr = xhr;  // store for cancel

            xhr.upload.addEventListener('progress', (e) => {
                if (!e.lengthComputable) return;
                const pct = Math.round((e.loaded / e.total) * 100);
                const elapsedSec = (Date.now() - uploadStartTime) / 1000;
                const speed = e.loaded / elapsedSec; // bytes/sec
                const remaining = (e.total - e.loaded) / speed;
                const etaStr = remaining > 60
                    ? `~${Math.ceil(remaining / 60)} min left`
                    : remaining > 5
                        ? `~${Math.ceil(remaining)}s left`
                        : '';
                const speedStr = speed > 1024 * 1024
                    ? `${(speed / (1024*1024)).toFixed(1)} MB/s`
                    : `${(speed / 1024).toFixed(0)} KB/s`;
                setProgress(pct, `ğŸ“¤ Uploading...`, `${pct}% Â· ${formatMediaSize(e.loaded)} / ${formatMediaSize(e.total)} Â· ${speedStr}`, etaStr);
            });

            xhr.upload.addEventListener('loadend', () => {
                // Upload complete â†’ switch to optimization stage
                completeStage(stageUpload);
                activateStage(stageOptimize);

                // Type-aware optimization progress
                if (isVideo || isAudio) {
                    const tool = isVideo ? 'ffmpeg (video)' : 'ffmpeg (audio)';
                    setProgress(0, `âš™ï¸ Optimizing with ${tool}...`, `Starting...`, '');

                    // Poll real ffmpeg progress from server every 2 seconds
                    window._mediaOptInterval = setInterval(async () => {
                        try {
                            const resp = await fetch('/api/content/media/optimize-status');
                            const data = await resp.json();

                            if (data.status !== 'encoding') return; // not active

                            const elapsed = data.elapsed || 0;
                            const elapsedStr = elapsed < 60
                                ? `${Math.round(elapsed)}s`
                                : `${(elapsed / 60).toFixed(1)} min`;

                            // Build progress info from real ffmpeg data
                            let detail = `${elapsedStr} elapsed`;
                            if (data.speed) detail += ` Â· ${data.speed} speed`;
                            if (data.fps) detail += ` Â· ${data.fps} fps`;

                            // Encode time position (e.g. "23:15 / 46:48")
                            let encoderInfo = data.encoder || tool;
                            if (data.time && data.time !== '00:00:00') {
                                encoderInfo += ` Â· encoded: ${data.time}`;
                            }

                            // Calculate progress from duration if available
                            let pct = 5;
                            if (data.duration_sec > 0 && data.time) {
                                const parts = data.time.split(':').map(Number);
                                const encodedSec = (parts[0] || 0) * 3600 + (parts[1] || 0) * 60 + (parts[2] || 0);
                                pct = Math.min(95, Math.round((encodedSec / data.duration_sec) * 100));
                            }

                            // Deadline warning â€” show extend button
                            const deadlineSec = data.deadline || 0;
                            const timeLeft = deadlineSec - elapsed;

                            if (data.deadline_warning) {
                                setProgress(pct, `â° Deadline reached â€” encoding still running`, detail, '');
                                // Show extend button if not already shown
                                if (!document.getElementById('media-extend-btn')) {
                                    const cancelRow = document.querySelector('#media-upload-zone .btn[onclick*="mediaCancelUpload"]')?.parentElement;
                                    if (cancelRow) {
                                        const extBtn = document.createElement('button');
                                        extBtn.id = 'media-extend-btn';
                                        extBtn.className = 'btn';
                                        extBtn.style.cssText = 'margin-left: 0.5rem; background: var(--accent); color: white;';
                                        extBtn.textContent = 'â° Extend +5 min';
                                        extBtn.onclick = async () => {
                                            extBtn.disabled = true;
                                            extBtn.textContent = 'Extending...';
                                            await fetch('/api/content/media/extend-optimize', {
                                                method: 'POST',
                                                headers: {'Content-Type': 'application/json'},
                                                body: JSON.stringify({extra_seconds: 300}),
                                            });
                                            extBtn.textContent = 'âœ… Extended!';
                                            setTimeout(() => extBtn.remove(), 2000);
                                            contentLog('â° Optimization deadline extended by 5 minutes');
                                        };
                                        cancelRow.appendChild(extBtn);
                                    }
                                }
                                progressBar.style.background = 'linear-gradient(90deg, var(--warning, #f59e0b), #fbbf24)';
                            } else if (timeLeft < 60 && timeLeft > 0) {
                                setProgress(pct, `âš™ï¸ Optimizing with ${encoderInfo}...`, detail, `â° ~${Math.ceil(timeLeft)}s left on deadline`);
                            } else {
                                setProgress(pct, `âš™ï¸ Optimizing with ${encoderInfo}...`, detail, '');
                            }
                        } catch (e) {
                            // Poll error â€” keep trying
                        }
                    }, 2000);
                } else if (isImage) {
                    setProgress(30, 'âš™ï¸ Compressing image â†’ WebP...', `Converting ${formatMediaSize(fileSize)}`, '');
                    let imgOptStart = Date.now();
                    window._mediaOptInterval = setInterval(() => {
                        const elapsed = Date.now() - imgOptStart;
                        const pct = Math.min(90, 30 + Math.round((1 - Math.exp(-elapsed / 10000)) * 60));
                        const bar = document.getElementById('media-progress-bar');
                        if (bar) bar.style.width = pct + '%';
                    }, 200);
                } else if (isPdf) {
                    setProgress(20, 'âš™ï¸ Optimizing PDF with Ghostscript...', `Processing ${formatMediaSize(fileSize)}`, '');
                    let pdfOptStart = Date.now();
                    window._mediaOptInterval = setInterval(() => {
                        const elapsed = Date.now() - pdfOptStart;
                        const pct = Math.min(90, 20 + Math.round((1 - Math.exp(-elapsed / 15000)) * 70));
                        const bar = document.getElementById('media-progress-bar');
                        if (bar) bar.style.width = pct + '%';
                    }, 300);
                } else {
                    // Text, JSON, CSV, etc â€” gzip is fast
                    setProgress(50, 'âš™ï¸ Compressing...', `Gzip: ${formatMediaSize(fileSize)}`, '');
                    window._mediaOptInterval = setInterval(() => {
                        const bar = document.getElementById('media-progress-bar');
                        const cur = parseFloat(bar.style.width) || 50;
                        if (cur < 90) bar.style.width = (cur + 5) + '%';
                    }, 100);
                }
            });

            xhr.addEventListener('load', () => {
                _mediaActiveXhr = null;
                if (window._mediaOptInterval) {
                    clearInterval(window._mediaOptInterval);
                    window._mediaOptInterval = null;
                }
                if (xhr.status >= 200 && xhr.status < 300) {
                    try {
                        resolve(JSON.parse(xhr.responseText));
                    } catch (e) {
                        reject(new Error('Server returned invalid JSON'));
                    }
                } else {
                    // Try to parse structured error from our endpoint
                    let errMsg = `Server error (HTTP ${xhr.status})`;
                    try {
                        const err = JSON.parse(xhr.responseText);
                        const stage = err.stage ? ` [${err.stage}]` : '';
                        errMsg = (err.error || errMsg) + stage;
                    } catch (e) {
                        // HTML error page or non-JSON response
                        if (xhr.responseText?.includes('Internal Server Error')) {
                            errMsg = `Server crashed (HTTP ${xhr.status}) â€” check server logs`;
                        }
                    }
                    reject(new Error(errMsg));
                }
            });

            xhr.addEventListener('error', () => {
                _mediaActiveXhr = null;
                if (window._mediaOptInterval) clearInterval(window._mediaOptInterval);
                reject(new Error('Network error'));
            });

            xhr.addEventListener('timeout', () => {
                _mediaActiveXhr = null;
                if (window._mediaOptInterval) clearInterval(window._mediaOptInterval);
                reject(new Error('Request timed out'));
            });

            xhr.addEventListener('abort', () => {
                _mediaActiveXhr = null;
                if (window._mediaOptInterval) clearInterval(window._mediaOptInterval);
                reject(new Error('Upload cancelled'));
            });

            xhr.open('POST', '/api/content/media/upload');
            xhr.timeout = 7200000; // 2 hours max for huge video encoding
            xhr.send(formData);
        });

        // â”€â”€ Stage 2 complete: Optimization done â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        completeStage(stageOptimize);

        if (response.success) {
            // Show results
            const origSize = response.original_size_bytes || fileSize;
            const finalSize = response.size_bytes || origSize;
            const savings = origSize > finalSize
                ? ` (${Math.round((1 - finalSize / origSize) * 100)}% smaller)`
                : '';

            // Optimization status info
            let optStatus = '';
            if (response.optimized) {
                optStatus = ` Â· âœ… optimized${savings}`;
            } else if (isVideo || isAudio) {
                optStatus = ' Â· âš ï¸ stored as-is (encoding skipped)';
            }

            // Browser compatibility warning for non-MP4/WebM video
            const mime = response.mime_type || '';
            const nonPlayable = isVideo && !['video/mp4', 'video/webm', 'video/ogg'].includes(mime);
            if (nonPlayable) {
                optStatus += ' Â· âš ï¸ format may not play in browser';
            }

            contentLog(`âœ… Media uploaded: ${response.id} (${response.original_name}, ${formatMediaSize(finalSize)}${savings})`);
            mediaPendingFile = null;
            mediaLoaded = false;

            // Stage 3: Release upload (if large tier)
            if (response.storage === 'large') {
                activateStage(stageRelease);
                completeStage(stageOptimize);
                setProgress(0, 'â˜ï¸ Uploading to GitHub Release...', 'Queued...', '');
                progressBar.style.background = 'linear-gradient(90deg, var(--accent), #818cf8)';

                // Poll release status until done/failed/cancelled
                const releaseMediaId = response.id;
                _mediaReleaseMediaId = releaseMediaId;
                const releaseStartTime = Date.now();
                _mediaReleasePollInterval = setInterval(async () => {
                    try {
                        const resp = await fetch(`/api/content/media/${releaseMediaId}/release-status`);
                        const data = await resp.json();

                        const elapsedSec = (Date.now() - releaseStartTime) / 1000;
                        const elapsedStr = elapsedSec > 60
                            ? `${(elapsedSec / 60).toFixed(1)} min`
                            : `${Math.round(elapsedSec)}s`;

                        if (data.status === 'done') {
                            clearInterval(_mediaReleasePollInterval);
                            _mediaReleasePollInterval = null;
                            completeStage(stageRelease);
                            setProgress(100, `âœ… Upload complete!`, `${formatMediaSize(finalSize)}${optStatus} Â· released in ${elapsedStr}`, '');
                            progressBar.style.background = 'linear-gradient(90deg, #22c55e, #4ade80)';
                            contentLog(`â˜ï¸ Release upload done: ${releaseMediaId} (${elapsedStr})`);
                            setTimeout(async () => {
                                progressContainer.style.display = 'none';
                                await loadMedia();
                                mediaSelectItem(releaseMediaId);
                            }, 2000);
                        } else if (data.status === 'failed') {
                            clearInterval(_mediaReleasePollInterval);
                            _mediaReleasePollInterval = null;
                            stageRelease.style.color = 'var(--danger, #ef4444)';
                            stageRelease.innerHTML = 'âœ— Release';
                            setProgress(100, `âš ï¸ Release upload failed`, data.message || 'Unknown error', '');
                            progressBar.style.background = 'var(--warning, #f59e0b)';
                            contentLog(`âš ï¸ Release upload failed: ${data.message}`, true);
                            // Still switch to detail view â€” local file is saved
                            setTimeout(async () => {
                                progressContainer.style.display = 'none';
                                await loadMedia();
                                mediaSelectItem(releaseMediaId);
                            }, 3000);
                        } else if (data.status === 'cancelled') {
                            clearInterval(_mediaReleasePollInterval);
                            _mediaReleasePollInterval = null;
                            _mediaReleaseMediaId = null;
                            // Already handled by cancel function
                            return;
                        } else {
                            // pending or uploading â€” show progress
                            // Asymptotic progress based on elapsed time (rough estimate)
                            const sizeMb = data.size_mb || (finalSize / (1024 * 1024));
                            const estSec = Math.max(30, sizeMb * 2); // ~2s per MB
                            const pct = Math.min(90, Math.round((1 - Math.exp(-elapsedSec / estSec * 2)) * 90));
                            setProgress(pct, `â˜ï¸ ${data.message || 'Uploading to release...'}`, `${pct}% Â· ${elapsedStr}`, '');
                        }
                    } catch (e) {
                        // Poll error â€” keep trying
                        console.warn('Release status poll error:', e);
                    }
                }, 3000); // Poll every 3 seconds
            } else {
                completeStage(stageRelease);
                stageRelease.innerHTML = 'âœ“ Git';
                setProgress(100, `âœ… Upload complete!`, `${formatMediaSize(finalSize)}${optStatus} Â· ${response.storage}`, '');
                progressBar.style.background = 'linear-gradient(90deg, #22c55e, #4ade80)';

                // Auto-switch to detail view after 2 seconds
                setTimeout(async () => {
                    progressContainer.style.display = 'none';
                    await loadMedia();
                    mediaSelectItem(response.id);
                }, 2000);
            }
        } else {
            throw new Error(response.error || 'Upload failed');
        }

    } catch (error) {
        if (window._mediaOptInterval) clearInterval(window._mediaOptInterval);
        _mediaActiveXhr = null;

        if (error.message === 'Upload cancelled') {
            // User cancelled â€” already handled by mediaCancelUploadInProgress
            return;
        }

        setProgress(100, `âŒ Failed: ${error.message}`, '', '');
        progressBar.style.background = 'var(--danger, #ef4444)';
        contentLog(`âŒ Upload error: ${error.message}`, true);

        // Allow retry after 3 seconds
        setTimeout(() => {
            progressContainer.style.display = 'none';
            mediaUploadPrompt();
        }, 3000);
    } finally {
        btn.disabled = false;
        btn.textContent = 'ğŸ“¤ Upload';
    }
}

// â”€â”€ Drag & drop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function initMediaDragDrop() {
    const dropzone = document.getElementById('media-dropzone');
    if (!dropzone) return;

    ['dragenter', 'dragover'].forEach(event => {
        dropzone.addEventListener(event, (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.add('drag-active');
        });
    });

    ['dragleave', 'drop'].forEach(event => {
        dropzone.addEventListener(event, (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('drag-active');
        });
    });

    dropzone.addEventListener('drop', (e) => {
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            const input = document.getElementById('media-file-input');
            input.files = files;
            mediaFileSelected({ target: input });
        }
    });

    // Click anywhere on dropzone to trigger file picker
    dropzone.addEventListener('click', (e) => {
        if (e.target.tagName !== 'BUTTON') {
            document.getElementById('media-file-input').click();
        }
    });
}

// Initialize drag/drop when DOM is ready
document.addEventListener('DOMContentLoaded', initMediaDragDrop);
// Also try immediately in case DOM is already loaded
if (document.readyState !== 'loading') initMediaDragDrop();

// â”€â”€ Update media field â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function mediaUpdateField(field, value) {
    if (!mediaSelectedId) return;

    try {
        const body = {};
        body[field] = value;

        const resp = await fetch(`/api/content/media/${mediaSelectedId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
        });
        const data = await resp.json();

        if (data.success) {
            contentLog(`âœ… Updated ${field} for ${mediaSelectedId}`);
            // Flash inline "âœ“ Saved"
            const statusEl = document.getElementById('media-save-status');
            if (statusEl) {
                statusEl.textContent = 'âœ“ Saved';
                statusEl.style.opacity = '1';
                clearTimeout(statusEl._fadeTimer);
                statusEl._fadeTimer = setTimeout(() => { statusEl.style.opacity = '0'; }, 2000);
            }
            // Update local cache
            const idx = mediaEntries.findIndex(m => m.id === mediaSelectedId);
            if (idx >= 0) Object.assign(mediaEntries[idx], data);
            renderMediaGallery();
        } else {
            contentLog(`âŒ Update failed: ${data.error}`, true);
        }
    } catch (error) {
        contentLog(`âŒ Update error: ${error.message}`, true);
    }
}

// â”€â”€ Toggle encryption â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function mediaToggleEncryption() {
    if (!mediaSelectedId) return;

    const item = mediaEntries.find(m => m.id === mediaSelectedId);
    if (!item) return;

    const action = item.encrypted ? 'decrypt' : 'encrypt';
    const btn = document.getElementById('media-toggle-encrypt-btn');
    btn.disabled = true;
    btn.textContent = `â³ ${action === 'encrypt' ? 'Encrypting' : 'Decrypting'}...`;

    try {
        const resp = await fetch(`/api/content/media/${mediaSelectedId}/toggle-encryption`, {
            method: 'POST',
        });
        const data = await resp.json();

        if (data.success) {
            const label = data.encrypted ? 'ğŸ”’ encrypted' : 'ğŸ“„ plaintext';
            contentLog(`âœ… Media ${mediaSelectedId} is now ${label}`);
            mediaLoaded = false;
            await loadMedia();
            mediaSelectItem(mediaSelectedId);
        } else {
            contentLog(`âŒ ${action} failed: ${data.error}`, true);
        }
    } catch (error) {
        contentLog(`âŒ ${action} error: ${error.message}`, true);
    } finally {
        btn.disabled = false;
    }
}

// â”€â”€ Delete media â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function mediaDeleteSelected() {
    if (!mediaSelectedId) return;

    const item = mediaEntries.find(m => m.id === mediaSelectedId);
    const name = item ? item.original_name : mediaSelectedId;

    if (!confirm(`Delete "${name}"? This will remove the file and cannot be undone.`)) return;

    try {
        let resp = await fetch(`/api/content/media/${mediaSelectedId}`, { method: 'DELETE' });
        let data = await resp.json();

        // Handle reference block (409)
        if (resp.status === 409 && data.requires_force) {
            const refs = (data.referenced_by || []).join(', ');
            if (!confirm(
                `âš ï¸ This media is referenced by: ${refs}\n\n` +
                `Deleting it will break those references.\n` +
                `Force delete anyway?`
            )) return;

            // Retry with force
            resp = await fetch(`/api/content/media/${mediaSelectedId}?force=true`, { method: 'DELETE' });
            data = await resp.json();
        }

        if (data.success) {
            contentLog(`ğŸ—‘ï¸ Deleted media: ${data.id} (${data.original_name})`);
            mediaSelectedId = null;
            mediaLoaded = false;
            await loadMedia();
            mediaUploadPrompt();
        } else {
            contentLog(`âŒ Delete failed: ${data.error}`, true);
        }
    } catch (error) {
        contentLog(`âŒ Delete error: ${error.message}`, true);
    }
}

// â”€â”€ Copy URI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function mediaCopyUri() {
    if (!mediaSelectedId) return;
    const uri = `media://${mediaSelectedId}`;
    navigator.clipboard.writeText(uri).then(() => {
        contentLog(`ğŸ“‹ Copied: ${uri}`);
    }).catch(() => {
        // Fallback: select the text
        const el = document.getElementById('media-detail-uri');
        const range = document.createRange();
        range.selectNodeContents(el);
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
        contentLog(`ğŸ“‹ URI selected â€” press Ctrl+C to copy`);
    });
}

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getMediaIcon(mimeType) {
    if (!mimeType) return 'ğŸ“';
    if (mimeType.startsWith('image/')) return 'ğŸ–¼ï¸';
    if (mimeType.startsWith('video/')) return 'ğŸ¬';
    if (mimeType.startsWith('audio/')) return 'ğŸµ';
    if (mimeType === 'application/pdf') return 'ğŸ“„';
    if (mimeType === 'application/json' || mimeType === 'application/xml') return 'ğŸ—‚ï¸';
    if (mimeType.startsWith('text/')) return 'ğŸ“';
    if (mimeType === 'message/rfc822') return 'âœ‰ï¸';
    if (['application/zip', 'application/gzip', 'application/x-tar',
         'application/x-7z-compressed'].includes(mimeType)) return 'ğŸ“¦';
    return 'ğŸ“';
}

function getStageColor(stage) {
    const colors = {
        'OK': 'var(--accent)',
        'REMIND_1': 'var(--info, #3b82f6)',
        'REMIND_2': 'var(--warning)',
        'PRE_RELEASE': 'var(--warning)',
        'PARTIAL': 'var(--danger)',
        'FULL': 'var(--danger)',
    };
    return colors[stage] || 'var(--text-dim)';
}

function formatMediaSize(bytes) {
    if (bytes === 0) return '0 B';
    const units = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    const val = (bytes / Math.pow(1024, i)).toFixed(i === 0 ? 0 : 1);
    return `${val} ${units[i]}`;
}
