
// ========================================
// MESSAGES MANAGEMENT (Content Tab â€” Messages Mode)
// ========================================

let messagesLoaded = false;
let messagesData = [];
let messagesTemplateFiles = [];   // Template files on disk
let messagesSelected = null;
let messagesDirty = false;
let messagesIsNew = false;
let messagesVariables = [];
let messagesRecipients = {};
let messagesEncryptionAvailable = false;
let _messagesPreviewTimer = null; // Debounce timer for live preview

// Hex-escaped template variable delimiters to avoid Jinja2 conflict
const MSG_VAR_OPEN = '$' + '\x7b\x7b';
const MSG_VAR_CLOSE = '\x7d\x7d';

// â”€â”€ Load all messages data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function messagesLoad() {
    try {
        const [msgResp, tplResp, varResp, rcpResp] = await Promise.all([
            fetch('/api/content/messages/list'),
            fetch('/api/content/messages/templates'),
            fetch('/api/content/messages/variables'),
            fetch('/api/content/messages/recipients'),
        ]);

        const msgData = await msgResp.json();
        const tplData = await tplResp.json();
        const varData = await varResp.json();
        const rcpData = await rcpResp.json();

        messagesData = msgData.messages || [];
        messagesTemplateFiles = tplData.templates || [];
        messagesVariables = varData.variables || [];
        messagesRecipients = {
            subscriber_emails: rcpData.subscriber_emails || [],
            custodian_emails: rcpData.custodian_emails || [],
            operator_email: rcpData.operator_email || '',
        };

        // Piggyback encryption_available from the content articles API
        // (key status is global, not per-mode)
        messagesEncryptionAvailable = !!contentEncryptionAvailable;

        messagesLoaded = true;
        messagesRenderList();
        messagesRenderVariableButtons();
        messagesRenderRecipients();
        messagesPopulateTemplatePicker();
        contentLog('\u2709\ufe0f Loaded ' + messagesData.length + ' messages, ' + messagesTemplateFiles.length + ' templates on disk');
    } catch (err) {
        contentLog('\u274c Failed to load messages: ' + err.message);
    }
}

// â”€â”€ Render message list grouped by stage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function messagesRenderList() {
    const container = document.getElementById('messages-list');
    if (!messagesData.length) {
        container.innerHTML = '<div style="color: var(--text-dim); font-size: 0.82rem; padding: 0.5rem 0;">No messages configured</div>';
        return;
    }

    const stages = ['REMIND_1', 'REMIND_2', 'PRE_RELEASE', 'PARTIAL', 'FULL'];
    const grouped = {};
    for (const s of stages) grouped[s] = [];
    for (const msg of messagesData) {
        const stage = msg.stage || 'REMIND_1';
        if (!grouped[stage]) grouped[stage] = [];
        grouped[stage].push(msg);
    }

    let html = '';
    for (const stage of stages) {
        const msgs = grouped[stage];
        if (!msgs.length) continue;

        html += '<div style="margin-bottom: 0.75rem;">';
        html += '<div style="font-size: 0.68rem; font-weight: 700; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.3rem; padding-left: 0.25rem;">' + stage.replace(/_/g, ' ') + '</div>';

        for (const msg of msgs) {
            const isActive = messagesSelected === msg.action_id;
            const bgColor = isActive ? 'background: var(--accent-dim, rgba(99,102,241,0.15)); border-color: var(--accent);' : '';
            const isEnabled = msg.enabled !== false;
            const opacity = (!msg.content_exists || !isEnabled) ? 'opacity: 0.45;' : '';
            const strikethrough = !isEnabled ? 'text-decoration: line-through;' : '';

            html += '<div class="messages-item" data-action-id="' + msg.action_id + '" ';
            html += 'style="display: flex; align-items: center; gap: 0.4rem; padding: 0.4rem 0.5rem; ';
            html += 'border-radius: 6px; cursor: pointer; border: 1px solid transparent; ';
            html += 'font-size: 0.82rem; transition: all 0.15s ease; ' + bgColor + opacity + '">';
            html += '<span style="flex-shrink: 0;">' + msg.icon + '</span>';
            html += '<span onclick="messagesSelect(\'' + msg.action_id.replace(/'/g, "\\'") + '\')" ';
            html += 'style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ' + strikethrough + '" title="' + msg.template + '">' + (msg.template || msg.action_id) + '</span>';
            html += '<span style="font-size: 0.65rem; padding: 0.1rem 0.3rem; border-radius: 3px; background: var(--bg-input); color: var(--text-dim);">' + msg.channel + '</span>';
            if (msg.encrypted) {
                html += '<span title="Encrypted at rest" style="font-size: 0.62rem; opacity: 0.7;">\ud83d\udd12</span>';
            }
            if (!msg.content_exists) {
                html += '<span title="Template file missing" style="font-size: 0.72rem;">âš ï¸</span>';
            }
            // Toggle switch
            html += '<label class="messages-toggle" title="' + (isEnabled ? 'Enabled â€” click to disable' : 'Disabled â€” click to enable') + '" ';
            html += 'onclick="event.stopPropagation(); messagesToggle(\'' + msg.action_id.replace(/'/g, "\\'") + '\')" ';
            html += 'style="position: relative; display: inline-block; width: 28px; height: 16px; flex-shrink: 0; cursor: pointer;">';
            html += '<span style="position: absolute; inset: 0; background: ' + (isEnabled ? 'var(--accent, #6366f1)' : 'var(--border, #444)') + '; border-radius: 8px; transition: background 0.2s;"></span>';
            html += '<span style="position: absolute; left: ' + (isEnabled ? '13px' : '2px') + '; top: 2px; width: 12px; height: 12px; background: white; border-radius: 50%; transition: left 0.2s;"></span>';
            html += '</label>';
            html += '</div>';
        }
        html += '</div>';
    }

    container.innerHTML = html;

    // Hover effects
    container.querySelectorAll('.messages-item').forEach(el => {
        el.addEventListener('mouseenter', () => {
            if (!el.style.background.includes('accent')) {
                el.style.background = 'var(--bg-input)';
            }
        });
        el.addEventListener('mouseleave', () => {
            if (!el.style.background.includes('accent')) {
                el.style.background = '';
            }
        });
    });
}

// â”€â”€ Toggle message enabled/disabled â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function messagesToggle(actionId) {
    try {
        const resp = await fetch('/api/content/messages/' + encodeURIComponent(actionId) + '/toggle', {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
        });
        const data = await resp.json();
        if (data.success) {
            // Update local data
            const msg = messagesData.find(m => m.action_id === actionId);
            if (msg) msg.enabled = data.enabled;
            messagesRenderList();
            // Refresh right panel if this is the selected message
            if (messagesSelected === actionId) {
                const wasDirty = messagesDirty;
                messagesSelect(actionId);
                messagesDirty = wasDirty;  // preserve dirty state
            }
            contentLog((data.enabled ? '\u2705 Enabled: ' : '\u23f8\ufe0f Disabled: ') + actionId);
        } else {
            contentLog('\u274c Toggle failed: ' + (data.error || 'Unknown error'));
        }
    } catch (err) {
        contentLog('\u274c Toggle error: ' + err.message);
    }
}

// â”€â”€ Populate template picker dropdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function messagesPopulateTemplatePicker() {
    const picker = document.getElementById('messages-template-picker');
    if (!picker) return;

    let html = '<option value="">\u2014 Pick existing template or type new \u2014</option>';

    // Group by directory
    const dirs = {};
    for (const t of messagesTemplateFiles) {
        const dir = t.dir || '(root)';
        if (!dirs[dir]) dirs[dir] = [];
        dirs[dir].push(t);
    }

    for (const [dir, templates] of Object.entries(dirs)) {
        html += '<optgroup label="' + dir + '/">';
        for (const t of templates) {
            html += '<option value="' + t.name + '" data-path="' + t.path + '" data-dir="' + t.dir + '">';
            html += t.name + t.ext + (t.encrypted ? ' \ud83d\udd12' : '');
            html += '</option>';
        }
        html += '</optgroup>';
    }

    picker.innerHTML = html;
}

// â”€â”€ Template picked from dropdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function messagesTemplatePicked() {
    const picker = document.getElementById('messages-template-picker');
    const templateName = picker.value;
    if (!templateName) return;

    // Set the template name input
    document.getElementById('messages-edit-template').value = templateName;

    // Auto-set the channel based on the template directory
    const selected = picker.options[picker.selectedIndex];
    const dir = selected.getAttribute('data-dir') || '';
    if (dir === 'operator') {
        document.getElementById('messages-edit-channel').value = 'operator';
    } else if (dir === 'custodians') {
        document.getElementById('messages-edit-channel').value = 'custodians';
    } else if (dir === 'public') {
        document.getElementById('messages-edit-channel').value = 'public';
    } else if (dir === 'subscribers') {
        document.getElementById('messages-edit-channel').value = 'subscribers';
    }

    // Auto-detect adapter from file extension
    const ext = (selected.textContent || '').trim();
    if (ext.endsWith('.txt')) {
        document.getElementById('messages-edit-adapter').value = 'sms';
    }

    // Load the template content
    try {
        const resp = await fetch('/api/content/messages/' + encodeURIComponent(templateName));
        if (resp.ok) {
            const data = await resp.json();
            document.getElementById('messages-edit-content').value = data.content || '';
            messagesUpdateAdapterHints(document.getElementById('messages-edit-adapter').value);
            messagesRefreshPreview();
            messagesMarkDirty();
        }
    } catch (err) {
        contentLog('\u274c Failed to load template: ' + err.message);
    }
}

// â”€â”€ Render variable insertion buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function messagesRenderVariableButtons() {
    const container = document.getElementById('messages-var-buttons');
    if (!container) return;

    let html = '<span style="font-size: 0.68rem; color: var(--text-dim); align-self: center; margin-right: 0.2rem;">Insert:</span>';

    for (const v of messagesVariables) {
        html += '<button class="btn" onclick="messagesInsertVar(\'' + v.name + '\')" ';
        html += 'title="' + v.description + '" ';
        html += 'style="padding: 0.1rem 0.35rem; font-size: 0.65rem; font-family: monospace; line-height: 1.2;">';
        html += v.name;
        html += '</button>';
    }

    container.innerHTML = html;
}

// â”€â”€ Render recipient lists â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function messagesRenderRecipients() {
    messagesRenderRecipientList('subscribers', messagesRecipients.subscriber_emails || []);
    messagesRenderRecipientList('custodians', messagesRecipients.custodian_emails || []);
}

function messagesRenderRecipientList(type, emails) {
    const container = document.getElementById('messages-' + type + '-list');
    if (!container) return;

    if (!emails.length) {
        container.innerHTML = '<div style="font-size: 0.75rem; color: var(--text-dim); font-style: italic;">None configured</div>';
        return;
    }

    let html = '';
    for (const email of emails) {
        html += '<div style="display: flex; align-items: center; gap: 0.25rem; padding: 0.15rem 0; font-size: 0.78rem;">';
        html += '<span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + email + '</span>';
        html += '<button class="btn" onclick="messagesRemoveRecipient(\'' + type + '\', \'' + email.replace(/'/g, "\\'") + '\')" ';
        html += 'style="padding: 0.05rem 0.25rem; font-size: 0.6rem; color: var(--danger); line-height: 1;" title="Remove">\u2715</button>';
        html += '</div>';
    }

    container.innerHTML = html;
}

// â”€â”€ Select a message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function messagesSelect(actionId) {
    if (messagesDirty) {
        if (!confirm('You have unsaved changes. Discard?')) return;
    }

    const msg = messagesData.find(m => m.action_id === actionId);
    if (!msg) return;

    messagesSelected = actionId;
    messagesIsNew = false;
    messagesDirty = false;

    messagesRenderList();

    // Show editor
    document.getElementById('messages-empty').style.display = 'none';
    document.getElementById('messages-editor-wrap').style.display = 'flex';
    document.getElementById('messages-panel-name').textContent = msg.template || msg.action_id;

    // Set dropdowns
    document.getElementById('messages-edit-stage').value = msg.stage;
    document.getElementById('messages-edit-adapter').value = msg.adapter;
    document.getElementById('messages-edit-channel').value = msg.channel;
    document.getElementById('messages-edit-template').value = msg.template || '';

    // Select in template picker if it matches
    const picker = document.getElementById('messages-template-picker');
    picker.value = msg.template || '';

    // Load template content
    if (msg.template && msg.content_exists) {
        try {
            const resp = await fetch('/api/content/messages/' + encodeURIComponent(msg.template));
            const data = await resp.json();
            document.getElementById('messages-edit-content').value = data.content || '';
        } catch (err) {
            document.getElementById('messages-edit-content').value = '';
            contentLog('\u274c Failed to load template: ' + err.message);
        }
    } else {
        document.getElementById('messages-edit-content').value = '';
        if (msg.template && !msg.content_exists) {
            contentLog('\u26a0\ufe0f Template file "' + msg.template + '" not found on disk');
        }
    }

    // Set encryption toggle to current state
    const encToggle = document.getElementById('messages-encrypt-toggle');
    if (encToggle) {
        encToggle.checked = !!msg.encrypted;
        updateMessagesEncryptNote();
    }

    // Update adapter hints + show correct preview
    messagesUpdateAdapterHints(msg.adapter);
    messagesShowPreviewForAdapter(msg.adapter);

    // Update badges
    const badges = document.getElementById('messages-panel-badges');
    const isEnabled = msg.enabled !== false;
    let badgesHtml = '<span style="font-size: 0.72rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: var(--accent-dim, rgba(99,102,241,0.15)); color: var(--accent);">' + msg.stage + '</span>'
        + '<span style="font-size: 0.72rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: var(--bg-input); color: var(--text-dim);">' + msg.adapter + '</span>';
    if (msg.encrypted) {
        badgesHtml += '<span style="font-size: 0.72rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: rgba(34,197,94,0.12); color: var(--success, #22c55e);" title="Encrypted at rest">\ud83d\udd12 Encrypted</span>';
    }
    // Enabled/disabled badge with toggle
    badgesHtml += '<span onclick="messagesToggle(\'' + msg.action_id.replace(/'/g, "\\\\'") + '\')" '
        + 'style="font-size: 0.72rem; padding: 0.15rem 0.5rem; border-radius: 999px; cursor: pointer; transition: all 0.2s; '
        + (isEnabled
            ? 'background: rgba(34,197,94,0.12); color: var(--success, #22c55e);" title="Enabled â€” click to disable">\u2705 Enabled'
            : 'background: rgba(239,68,68,0.12); color: var(--danger, #ef4444);" title="Disabled â€” click to enable">\u23f8\ufe0f Disabled')
        + '</span>';
    badges.innerHTML = badgesHtml;

    // Trigger preview
    messagesRefreshPreview();
    messagesDirty = false;

    // Reset status
    const status = document.getElementById('messages-save-status');
    if (status) status.style.opacity = '0';
}

// â”€â”€ New message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function messagesNew() {
    if (messagesDirty) {
        if (!confirm('You have unsaved changes. Discard?')) return;
    }

    messagesSelected = null;
    messagesIsNew = true;
    messagesDirty = false;

    messagesRenderList();

    document.getElementById('messages-empty').style.display = 'none';
    document.getElementById('messages-editor-wrap').style.display = 'flex';
    document.getElementById('messages-panel-name').textContent = 'New Message';

    // Reset form
    document.getElementById('messages-edit-stage').value = 'REMIND_1';
    document.getElementById('messages-edit-adapter').value = 'email';
    document.getElementById('messages-edit-channel').value = 'operator';
    document.getElementById('messages-edit-template').value = '';
    document.getElementById('messages-edit-content').value = '';
    document.getElementById('messages-template-picker').value = '';

    messagesUpdateAdapterHints('email');
    messagesShowPreviewForAdapter('email');

    // Clear preview iframe
    const iframe = document.getElementById('messages-preview-iframe');
    if (iframe) iframe.srcdoc = '';

    document.getElementById('messages-panel-badges').innerHTML = '<span style="font-size: 0.72rem; padding: 0.15rem 0.5rem; border-radius: 999px; background: var(--success-dim, rgba(34,197,94,0.15)); color: var(--success, #22c55e);">NEW</span>';

    // Default encrypt toggle to key availability for new messages
    const encToggle = document.getElementById('messages-encrypt-toggle');
    if (encToggle) {
        encToggle.checked = !!messagesEncryptionAvailable;
        updateMessagesEncryptNote();
    }

    messagesDirty = false;
    const status = document.getElementById('messages-save-status');
    if (status) status.style.opacity = '0';
}

// â”€â”€ Dirty tracking + debounced preview â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function messagesMarkDirty() {
    messagesDirty = true;
    const status = document.getElementById('messages-save-status');
    if (status) {
        status.textContent = '\u270f\ufe0f Unsaved changes';
        status.style.opacity = '1';
    }
}

function messagesContentChanged() {
    messagesMarkDirty();
    // Debounce the preview refresh (300ms)
    if (_messagesPreviewTimer) clearTimeout(_messagesPreviewTimer);
    _messagesPreviewTimer = setTimeout(messagesRefreshPreview, 300);
}

// â”€â”€ Adapter change handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function messagesAdapterChanged() {
    messagesMarkDirty();
    const adapter = document.getElementById('messages-edit-adapter').value;
    messagesUpdateAdapterHints(adapter);
    messagesShowPreviewForAdapter(adapter);
    messagesRefreshPreview();
}

// â”€â”€ Show / hide the correct preview container â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function messagesShowPreviewForAdapter(adapter) {
    const panels = {
        'email': 'messages-preview-iframe',
        'sms': 'messages-preview-sms',
        'x': 'messages-preview-x',
        'reddit': 'messages-preview-reddit',
    };

    // Hide all
    document.getElementById('messages-preview-iframe').style.display = 'none';
    document.getElementById('messages-preview-sms').style.display = 'none';
    document.getElementById('messages-preview-x').style.display = 'none';
    document.getElementById('messages-preview-reddit').style.display = 'none';
    document.getElementById('messages-preview-generic').style.display = 'none';

    // Show the right one
    const target = panels[adapter];
    if (target) {
        document.getElementById(target).style.display = adapter === 'email' ? '' : 'flex';
    } else {
        document.getElementById('messages-preview-generic').style.display = 'flex';
    }
}

// â”€â”€ Update adapter-specific hints â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function messagesUpdateAdapterHints(adapter) {
    const hints = document.getElementById('messages-adapter-hints');
    if (!hints) return;

    const hintMap = {
        'email': '\ud83d\udce7 # Header \u2192 subject. Body \u2192 styled HTML. \ud83d\udcf8 Images supported.',
        'sms': '\ud83d\udcf1 Plain text. 160c/segment. Media \u2192 text labels.',
        'x': '\ud83d\udc26 280 chars. No markdown. Media stripped.',
        'reddit': '\ud83e\udd16 # Header \u2192 post title. Images if hosted URL.',
    };

    hints.textContent = hintMap[adapter] || '';
}

// â”€â”€ Insert variable â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function messagesInsertVar(varName) {
    const textarea = document.getElementById('messages-edit-content');
    if (!textarea) return;

    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = textarea.value;
    const insert = MSG_VAR_OPEN + varName + MSG_VAR_CLOSE;

    textarea.value = text.substring(0, start) + insert + text.substring(end);
    textarea.selectionStart = textarea.selectionEnd = start + insert.length;
    textarea.focus();
    messagesContentChanged();
}

// â”€â”€ Insert media (vault picker + paste) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Open vault picker in messages mode.
 * Sets the target so the shared picker inserts markdown syntax instead of EditorJS blocks.
 */
function messagesOpenVaultPicker() {
    vaultPickerTarget = 'messages';
    openVaultPicker();
}

/**
 * Insert a markdown media snippet at cursor position in the messages textarea.
 * Called by the vault picker when target === 'messages'.
 *
 * @param {string} markdownSnippet  e.g. "![caption](media://img_001)"
 */
function messagesInsertMedia(markdownSnippet) {
    const textarea = document.getElementById('messages-edit-content');
    if (!textarea) return;

    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = textarea.value;

    // Ensure media goes on its own line for clean markdown
    let before = text.substring(0, start);
    let after = text.substring(end);
    if (before.length > 0 && !before.endsWith('\n')) before += '\n';
    if (after.length > 0 && !after.startsWith('\n')) after = '\n' + after;

    const insert = markdownSnippet;
    textarea.value = before + insert + after;
    textarea.selectionStart = textarea.selectionEnd = before.length + insert.length;
    textarea.focus();
    messagesContentChanged();
}

/**
 * Handle paste events on the messages textarea.
 * If the clipboard contains an image, upload it via the editor-upload endpoint
 * and insert markdown syntax at the cursor position.
 */
function messagesSetupPasteHandler() {
    const textarea = document.getElementById('messages-edit-content');
    if (!textarea) return;

    textarea.addEventListener('paste', async (e) => {
        const items = e.clipboardData?.items;
        if (!items) return;

        // Check for image in clipboard
        let imageItem = null;
        for (const item of items) {
            if (item.type.startsWith('image/')) {
                imageItem = item;
                break;
            }
        }
        if (!imageItem) return;  // No image â€” let default paste proceed

        e.preventDefault();
        const file = imageItem.getAsFile();
        if (!file) return;

        // Create or reuse upload toast
        let toast = document.getElementById('editor-upload-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'editor-upload-toast';
            toast.style.cssText = `
                position: fixed; bottom: 1.5rem; right: 1.5rem; z-index: 9999;
                background: var(--surface, #1a1a2e); border: 1px solid var(--border, #333);
                border-radius: 8px; padding: 0.75rem 1rem; min-width: 280px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.4); cursor: pointer;
                font-size: 0.82rem; color: var(--text, #e0e0e0);
            `;
            toast.title = 'Click to cancel';
            document.body.appendChild(toast);
        }
        toast.style.display = 'block';
        toast.innerHTML = `
            <div style="margin-bottom: 0.4rem; font-weight: 500;">ğŸ“¤ Uploading pasted image...</div>
            <div style="height: 4px; background: var(--surface-alt, #2a2a3a); border-radius: 2px; overflow: hidden;">
                <div id="editor-upload-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), #60a5fa); transition: width 0.2s;"></div>
            </div>
            <div id="editor-upload-detail" style="font-size: 0.72rem; color: var(--text-dim); margin-top: 0.3rem;">0%</div>
        `;

        const formData = new FormData();
        formData.append('image', file, file.name || 'pasted-image.png');

        const xhr = new XMLHttpRequest();

        toast.onclick = () => {
            xhr.abort();
            toast.style.display = 'none';
            contentLog('âš ï¸ Paste upload cancelled');
        };

        xhr.upload.addEventListener('progress', (ev) => {
            if (!ev.lengthComputable) return;
            const pct = Math.round((ev.loaded / ev.total) * 100);
            const bar = document.getElementById('editor-upload-bar');
            if (bar) bar.style.width = pct + '%';
            const detail = document.getElementById('editor-upload-detail');
            if (detail) detail.textContent = `${pct}%`;
        });

        xhr.addEventListener('load', () => {
            const bar = document.getElementById('editor-upload-bar');
            if (xhr.status >= 200 && xhr.status < 300) {
                try {
                    const data = JSON.parse(xhr.responseText);
                    if (data.success) {
                        if (bar) bar.style.background = 'linear-gradient(90deg, #22c55e, #4ade80)';
                        if (bar) bar.style.width = '100%';

                        let mdSnippet;
                        if (data.inline) {
                            // Small file â€” inlined as data: URI
                            mdSnippet = `![pasted image](${data.file.url})`;
                            contentLog(`ğŸ–¼ï¸ Pasted image inlined (${typeof formatMediaSize === 'function' ? formatMediaSize(data.size_bytes) : data.size_bytes + ' B'})`);
                        } else {
                            // Vault file â€” use media:// URI
                            mdSnippet = `![pasted image](${data.media_uri})`;
                            contentLog(`ğŸ–¼ï¸ Pasted image â†’ vault: ${data.media_id}`);
                        }
                        messagesInsertMedia(mdSnippet);
                        setTimeout(() => { toast.style.display = 'none'; }, 1500);
                    } else {
                        contentLog(`âŒ Paste upload failed: ${data.error}`, true);
                        toast.style.display = 'none';
                    }
                } catch (parseErr) {
                    contentLog('âŒ Paste upload: invalid server response', true);
                    toast.style.display = 'none';
                }
            } else {
                let errMsg = `Server error (HTTP ${xhr.status})`;
                try {
                    const errData = JSON.parse(xhr.responseText);
                    errMsg = errData.error || errMsg;
                } catch (_) {}
                if (bar) bar.style.background = 'var(--danger, #ef4444)';
                contentLog(`âŒ Paste upload: ${errMsg}`, true);
                setTimeout(() => { toast.style.display = 'none'; }, 3000);
            }
        });

        xhr.addEventListener('error', () => {
            contentLog('âŒ Paste upload network error', true);
            toast.style.display = 'none';
        });

        xhr.open('POST', '/api/content/media/editor-upload');
        xhr.timeout = 60000;
        xhr.send(formData);
    });
}

// Initialize paste handler when DOM is ready
messagesSetupPasteHandler();

// â”€â”€ Live Preview (API call) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function messagesRefreshPreview() {
    const content = document.getElementById('messages-edit-content').value;
    const adapter = document.getElementById('messages-edit-adapter').value;
    const stage = document.getElementById('messages-edit-stage').value;
    const metaEl = document.getElementById('messages-preview-meta');

    if (!content.trim()) {
        // Show empty state in all previews
        const iframe = document.getElementById('messages-preview-iframe');
        if (iframe) iframe.srcdoc = '<body style="margin:0;background:#1a1a2e;display:flex;align-items:center;justify-content:center;height:100vh;color:#64748b;font-family:sans-serif;font-size:13px;">(empty)</body>';
        const smsBubble = document.getElementById('messages-preview-sms-bubble');
        if (smsBubble) smsBubble.textContent = '(empty)';
        const xText = document.getElementById('messages-preview-x-text');
        if (xText) xText.textContent = '(empty)';
        const redditTitle = document.getElementById('messages-preview-reddit-title');
        if (redditTitle) redditTitle.textContent = '(empty)';
        const genericContent = document.getElementById('messages-preview-generic-content');
        if (genericContent) genericContent.textContent = '(empty)';
        if (metaEl) metaEl.textContent = '';
        return;
    }

    try {
        const resp = await fetch('/api/content/messages/preview', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content, adapter, stage }),
        });

        const data = await resp.json();

        if (adapter === 'email') {
            // Render full styled HTML in iframe
            const iframe = document.getElementById('messages-preview-iframe');
            if (iframe && data.html) {
                iframe.srcdoc = data.html;
            }
            if (metaEl) metaEl.textContent = 'Subject: ' + (data.subject || '');

        } else if (adapter === 'sms') {
            const bubble = document.getElementById('messages-preview-sms-bubble');
            const smsMeta = document.getElementById('messages-preview-sms-meta');
            if (bubble) {
                // Build bubble content: media images + text
                let html = '';

                // MMS media attachments
                const attachments = data.media_attachments || [];
                if (attachments.length > 0) {
                    html += '<div style="margin: -0.75rem -1rem 0.6rem -1rem; border-radius: 16px 16px 0 0; overflow: hidden;">';
                    for (const att of attachments) {
                        html += `<img src="${att.url}" alt="${att.caption}"
                            style="width: 100%; display: block; max-height: 200px; object-fit: cover;"
                            onerror="this.outerHTML='<div style=\\'padding: 0.75rem; text-align: center; color: #94a3b8; font-size: 0.78rem;\\'>ğŸ”’ Image unavailable</div>'">`;
                        // Show the public URL Twilio will fetch
                        if (att.public_url) {
                            html += `<div style="padding: 0.25rem 0.6rem; font-size: 0.65rem; color: #93c5fd; background: rgba(0,0,0,0.3); word-break: break-all; font-family: monospace;"
                                title="URL sent to Twilio">ğŸ”— ${att.public_url}</div>`;
                        } else {
                            html += `<div style="padding: 0.25rem 0.6rem; font-size: 0.65rem; color: #f59e0b; background: rgba(0,0,0,0.3);">âš ï¸ Public URL could not be resolved</div>`;
                        }
                    }
                    html += '</div>';
                }

                // Text body
                const plainText = data.plain_text || data.rendered || '';
                html += `<span>${plainText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\n/g, '<br>')}</span>`;
                bubble.innerHTML = html;
            }
            if (smsMeta) {
                const chars = data.char_count || 0;
                const segs = data.segments || 1;
                const media = (data.media_attachments || []).length;
                const over = data.over_limit ? ' \u26a0\ufe0f OVER' : '';
                const mmsTag = media > 0 ? `ğŸ“· MMS (${media} image${media !== 1 ? 's' : ''}) \u2022 ` : '';
                smsMeta.textContent = mmsTag + chars + ' chars \u2022 ' + segs + ' segment' + (segs !== 1 ? 's' : '') + over;
            }
            if (metaEl) metaEl.textContent = (data.char_count || 0) + ' chars';

        } else if (adapter === 'x') {
            const xText = document.getElementById('messages-preview-x-text');
            const xMeta = document.getElementById('messages-preview-x-meta');
            if (xText) xText.textContent = data.text || data.rendered || '';
            if (xMeta) {
                const cc = data.char_count || 0;
                const color = cc > 280 ? 'var(--danger)' : 'var(--text-dim)';
                xMeta.innerHTML = '<span style="color:' + color + '">' + cc + '/280</span>' + (cc > 280 ? ' \u26a0\ufe0f Over limit!' : '');
            }
            if (metaEl) metaEl.textContent = (data.char_count || 0) + '/280';

        } else if (adapter === 'reddit') {
            const rTitle = document.getElementById('messages-preview-reddit-title');
            const rBody = document.getElementById('messages-preview-reddit-body');
            if (rTitle) rTitle.textContent = data.title || '';
            if (rBody) rBody.textContent = data.body || '';
            if (metaEl) metaEl.textContent = '';

        } else {
            // Generic / article
            const genContent = document.getElementById('messages-preview-generic-content');
            if (genContent) genContent.textContent = data.rendered || '';
            if (metaEl) metaEl.textContent = '';
        }

    } catch (err) {
        if (metaEl) metaEl.textContent = 'Preview error';
    }
}

// â”€â”€ Save message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function messagesSave() {
    const template = document.getElementById('messages-edit-template').value.trim();
    const stage = document.getElementById('messages-edit-stage').value;
    const adapter = document.getElementById('messages-edit-adapter').value;
    const channel = document.getElementById('messages-edit-channel').value;
    const content = document.getElementById('messages-edit-content').value;

    if (!template) {
        contentLog('\u274c Template name is required');
        return;
    }
    if (!/^[a-zA-Z0-9_]+$/.test(template)) {
        contentLog('\u274c Template name must be alphanumeric with underscores only');
        return;
    }

    // Encryption flag from toggle
    const encrypt = document.getElementById('messages-encrypt-toggle')?.checked || false;
    if (encrypt && !messagesEncryptionAvailable) {
        contentLog('\u26a0\ufe0f Cannot encrypt \u2014 CONTENT_ENCRYPTION_KEY is not set.\nGo to Secrets \u2192 Security to configure it.', true);
        return;
    }

    const body = { template, stage, adapter, channel, content, encrypt };

    if (!messagesIsNew && messagesSelected) {
        body.action_id = messagesSelected;
    }

    try {
        const resp = await fetch('/api/content/messages/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
        });

        const data = await resp.json();

        if (!resp.ok) {
            contentLog('\u274c Save failed: ' + (data.error || 'Unknown error'));
            return;
        }

        messagesDirty = false;
        messagesIsNew = false;
        messagesSelected = data.action_id;

        const status = document.getElementById('messages-save-status');
        if (status) {
            status.textContent = '\u2705 Saved';
            status.style.opacity = '1';
            setTimeout(() => { status.style.opacity = '0'; }, 2000);
        }

        const encLabel = data.encrypted ? ' \ud83d\udd12' : '';
        contentLog('\u2709\ufe0f Saved: ' + template + ' \u2192 ' + stage + ' (' + adapter + ' \u2192 ' + channel + ')' + encLabel);

        // Reload everything
        await messagesLoad();
        messagesSelect(data.action_id);

    } catch (err) {
        contentLog('\u274c Save error: ' + err.message);
    }
}

// â”€â”€ Delete message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function messagesDelete() {
    if (!messagesSelected && !messagesIsNew) return;

    if (messagesIsNew) {
        messagesDiscard();
        return;
    }

    const msg = messagesData.find(m => m.action_id === messagesSelected);
    if (!msg) return;

    const name = msg.template || msg.action_id;
    if (!confirm('Delete message "' + name + '"?\nThis removes the template file and plan action.')) return;

    try {
        const resp = await fetch('/api/content/messages/' + encodeURIComponent(msg.template) + '?action_id=' + encodeURIComponent(msg.action_id), {
            method: 'DELETE',
        });

        const data = await resp.json();

        if (data.success) {
            contentLog('\ud83d\uddd1\ufe0f Deleted: ' + name);
            messagesDirty = false;
            messagesSelected = null;
            messagesResetEditor();
            await messagesLoad();
        } else {
            contentLog('\u274c Delete failed');
        }
    } catch (err) {
        contentLog('\u274c Delete error: ' + err.message);
    }
}

// â”€â”€ Discard changes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function messagesDiscard() {
    messagesDirty = false;

    if (messagesIsNew) {
        messagesIsNew = false;
        messagesSelected = null;
        messagesResetEditor();
    } else if (messagesSelected) {
        messagesSelect(messagesSelected);
    }

    const status = document.getElementById('messages-save-status');
    if (status) status.style.opacity = '0';
}

function messagesResetEditor() {
    document.getElementById('messages-empty').style.display = '';
    document.getElementById('messages-editor-wrap').style.display = 'none';
    document.getElementById('messages-panel-name').textContent = 'Select a message';
    document.getElementById('messages-panel-badges').innerHTML = '';

    // Clear iframe
    const iframe = document.getElementById('messages-preview-iframe');
    if (iframe) iframe.srcdoc = '';
}

// â”€â”€ Recipient management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function messagesAddRecipient(type) {
    const inputId = type === 'subscriber' ? 'messages-add-subscriber' : 'messages-add-custodian';
    const input = document.getElementById(inputId);
    if (!input) return;

    const email = input.value.trim();
    if (!email || !email.includes('@')) {
        contentLog('\u274c Invalid email address');
        return;
    }

    const key = type === 'subscriber' ? 'subscriber_emails' : 'custodian_emails';
    const current = messagesRecipients[key] || [];

    if (current.includes(email)) {
        contentLog('\u26a0\ufe0f Already in list');
        return;
    }

    const body = {};
    body[key] = [...current, email];

    try {
        const resp = await fetch('/api/content/messages/recipients', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
        });

        const data = await resp.json();
        if (data.success) {
            messagesRecipients[key] = data[key] || body[key];
            messagesRenderRecipients();
            input.value = '';
            contentLog('\u2705 Added ' + type + ': ' + email);
        } else {
            contentLog('\u274c Failed to update recipients');
        }
    } catch (err) {
        contentLog('\u274c Error: ' + err.message);
    }
}

async function messagesRemoveRecipient(type, email) {
    const key = type === 'subscriber' ? 'subscriber_emails' : 'custodian_emails';
    const current = messagesRecipients[key] || [];
    const body = {};
    body[key] = current.filter(e => e !== email);

    try {
        const resp = await fetch('/api/content/messages/recipients', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
        });

        const data = await resp.json();
        if (data.success) {
            messagesRecipients[key] = data[key] || body[key];
            messagesRenderRecipients();
            contentLog('\ud83d\uddd1\ufe0f Removed ' + type + ': ' + email);
        }
    } catch (err) {
        contentLog('\u274c Error: ' + err.message);
    }
}

// â”€â”€ Encryption toggle note â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function updateMessagesEncryptNote() {
    const note = document.getElementById('messages-encrypt-note');
    if (!note) return;
    const checked = document.getElementById('messages-encrypt-toggle')?.checked;
    if (checked && !messagesEncryptionAvailable) {
        note.innerHTML = '<span style="color: var(--danger);">\u26a0\ufe0f Key not set \u2014 encryption will fail</span>';
    } else if (checked) {
        note.textContent = 'Template will be encrypted before saving to disk';
    } else {
        note.textContent = 'Template will be saved as plaintext';
    }
}

// Attach toggle listener
document.getElementById('messages-encrypt-toggle')?.addEventListener('change', function() {
    messagesMarkDirty();
    updateMessagesEncryptNote();
});
