// ========================================
// CONTENT TAB
// ========================================

let contentLoaded = false;
let contentArticles = [];
let contentSelectedSlug = null;
let contentEditor = null;
let contentEncryptionAvailable = false;
let contentOriginalData = null; // For dirty tracking
let contentDirty = false;

// â”€â”€ Load content data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function loadContent() {
try {
// Load articles list
const resp = await fetch('/api/content/articles');
const data = await resp.json();
contentArticles = data.articles || [];
contentEncryptionAvailable = data.encryption_available;

renderContentKeyBar();
renderContentList();
contentLoaded = true;
} catch (error) {
document.getElementById('content-article-list').innerHTML =
`<div style="color: var(--danger); font-size: 0.85rem;">âŒ Failed to load: ${error.message}</div>`;
}
}

// â”€â”€ Encryption key status bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderContentKeyBar() {
const el = document.getElementById('content-key-status');
if (contentEncryptionAvailable) {
el.innerHTML = `
<span style="color: var(--accent);">ğŸ”‘ Encryption key: âœ… Configured</span>`;
document.getElementById('content-gen-key-btn').style.display = 'none';
} else {
el.innerHTML = `
<span style="color: var(--warning);">ğŸ”‘ Encryption key: âš ï¸ Not set</span>
<span style="font-size: 0.78rem; color: var(--text-dim);">
    â€” set via <a href="#secrets" onclick="switchTab('secrets'); return false;" style="color: var(--info);">Secrets</a>
    or <a href="#wizard/security" onclick="goToWizardStep('security'); return false;"
        style="color: var(--info);">Wizard</a>
</span>`;
document.getElementById('content-gen-key-btn').style.display = '';
}
}

async function contentGenerateKey() {
try {
const response = await fetch('/api/content/keygen', { method: 'POST' });
const data = await response.json();
if (data.error) {
contentLog(`âŒ Failed to generate key: ${data.error}`, true);
return;
}
// Show the key and guide user to save it
contentLog(
`ğŸ”‘ Generated key:\n\n ${data.key}\n\n` +
`âš ï¸ This key is NOT saved yet!\n` +
`Go to ğŸ” Secrets â†’ Security â†’ CONTENT_ENCRYPTION_KEY\n` +
`and paste it there, then Save & Push.`
);
// Also copy to clipboard
try {
await navigator.clipboard.writeText(data.key);
contentLog(`\nğŸ“‹ Key copied to clipboard.`);
} catch (e) { /* clipboard not available */ }
} catch (error) {
contentLog(`âŒ Error: ${error.message}`, true);
}
}

// â”€â”€ Article list â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderContentList() {
const el = document.getElementById('content-article-list');

if (contentArticles.length === 0) {
el.innerHTML = `
<div style="text-align: center; padding: 1.5rem 0; color: var(--text-dim);">
    <div style="font-size: 2rem; margin-bottom: 0.5rem; opacity: 0.3;">ğŸ“„</div>
    <p style="font-size: 0.85rem;">No articles yet</p>
    <button class="btn primary" onclick="contentNewArticle()" style="margin-top: 0.75rem; font-size: 0.82rem;">
        â• Create your first article
    </button>
</div>`;
return;
}

let html = '<div style="display: flex; flex-direction: column; gap: 0.25rem;">';
    for (const art of contentArticles) {
    const isSelected = art.slug === contentSelectedSlug;
    const icon = art.encrypted ? 'ğŸ”’' : 'ğŸ“„';
    const stageColor = {
    'OK': 'var(--accent)',
    'WARNING': 'var(--warning)',
    'CRITICAL': 'var(--danger)',
    'FINAL': 'var(--danger)',
    'FULL': 'var(--danger)',
    }[art.min_stage] || 'var(--text-dim)';

    html += `
    <div onclick="contentSelectArticle('${art.slug}')" class="content-article-row ${isSelected ? 'selected' : ''}"
        style="display: flex; align-items: center; gap: 0.6rem; padding: 0.6rem 0.75rem;
                                border-radius: 8px; cursor: pointer; transition: all 0.15s;
                                background: ${isSelected ? 'var(--accent-dim)' : 'transparent'};
                                border: 1px solid ${isSelected ? 'rgba(74,222,128,0.3)' : 'transparent'};">
        <span style="font-size: 1.1rem;">${icon}</span>
        <div style="flex: 1; min-width: 0;">
            <div translate="no" style="font-size: 0.88rem; font-weight: ${isSelected ? '600' : '500'}; 
                                        color: ${isSelected ? 'var(--accent)' : 'var(--text)'}; 
                                        white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                ${art.title}
            </div>
            <div translate="no" style="font-size: 0.72rem; color: var(--text-dim); margin-top: 0.1rem;">
                ${art.slug}
            </div>
        </div>
        ${art.min_stage ? `<span translate="no" style="font-size: 0.68rem; padding: 0.1rem 0.4rem; border-radius: 4px;
                            background: ${stageColor}22; color: ${stageColor}; font-weight: 500;">
            ${art.min_stage}</span>` : ''}
    </div>`;
    }
    html += '</div>';
el.innerHTML = html;
}

// â”€â”€ Select article â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentSelectArticle(slug) {
// Warn if dirty
if (contentDirty && contentSelectedSlug) {
if (!confirm('You have unsaved changes. Discard and switch article?')) return;
}

contentSelectedSlug = slug;
contentDirty = false;
contentEditorReady = false;
const statusEl = document.getElementById('content-save-status');
if (statusEl) statusEl.style.opacity = '0';
renderContentList();

// Show loading state in editor
document.getElementById('content-editor-slug').textContent = slug;
document.getElementById('content-editor-empty').style.display = 'none';
document.getElementById('content-editorjs-wrap').style.display = 'block';
document.getElementById('content-editor-controls').style.display = 'block';
document.getElementById('content-meta-panel').style.display = 'block';
document.getElementById('content-editorjs').innerHTML = '<div class="loading">Loading article</div>';

try {
const resp = await fetch(`/api/content/articles/${slug}`);
const data = await resp.json();

if (data.error) {
document.getElementById('content-editorjs').innerHTML =
`<div style="padding: 1rem; color: var(--danger); font-size: 0.9rem;">
    âš ï¸ ${data.error}
</div>`;
return;
}

// Update badges
const badges = document.getElementById('content-editor-badges');
badges.innerHTML = '';
if (data.encrypted) {
badges.innerHTML += '<span class="badge warning" style="font-size: 0.72rem; padding: 0.15rem 0.5rem;">ğŸ”’ Encrypted</span>';
}

// Set encryption toggle
const encToggle = document.getElementById('content-encrypt-toggle');
encToggle.checked = !!data.encrypted;
updateEncryptNote();

// Set metadata fields
if (data.manifest_entry) {
const me = data.manifest_entry;
document.getElementById('content-meta-stage').value = me.min_stage || 'FULL';
document.getElementById('content-meta-nav').checked = me.include_in_nav !== false;
document.getElementById('content-meta-pin').checked = !!me.pin_to_top;
}

// Initialize Editor.js â€” rewrite media:// URIs for preview
contentOriginalData = data.content;
const editorData = contentRewriteMediaUrls(data.content, 'toPreview');
await initContentEditor(editorData);

} catch (error) {
document.getElementById('content-editorjs').innerHTML =
`<div style="padding: 1rem; color: var(--danger);">âŒ Failed to load: ${error.message}</div>`;
}
}

// â”€â”€ Custom EditorJS tools for media blocks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * VideoTool â€” Renders a video player in the editor.
 * Data: { url, caption, poster }
 */
class VideoTool {
    static get toolbox() {
        return { title: 'Video', icon: '<svg width="17" height="15" viewBox="0 0 17 15"><path d="M2 2h10v10H2z" stroke="currentColor" fill="none" stroke-width="1.5"/><path d="M13 5l3-2v9l-3-2" stroke="currentColor" fill="none" stroke-width="1.5"/></svg>' };
    }
    constructor({ data, config, api }) {
        this.data = Object.assign({ url: '', caption: '', poster: '' }, data);
        this.api = api;
        this.wrapper = null;
    }
    render() {
        this.wrapper = document.createElement('div');
        this.wrapper.style.cssText = 'border: 1px solid var(--border); border-radius: 8px; overflow: hidden; background: #111;';
        this._renderContent();
        return this.wrapper;
    }
    _renderContent() {
        const url = this.data.url;
        const isPreview = url && (url.startsWith('/api/') || url.startsWith('http') || url.startsWith('blob:'));

        this.wrapper.innerHTML = `
            <div style="position: relative; min-height: 180px; display: flex; align-items: center; justify-content: center;">
                ${isPreview
                    ? `<video controls preload="metadata" style="width: 100%; max-height: 400px; display: block;">
                        <source src="${url}"></video>`
                    : `<div style="text-align: center; padding: 2rem; color: var(--text-dim);">
                        <div style="font-size: 3rem; opacity: 0.3;">ğŸ¬</div>
                        <p style="font-size: 0.85rem; margin-top: 0.5rem;">${url ? url : 'No video selected â€” use ğŸ“ Insert Media'}</p>
                       </div>`
                }
            </div>
            <input type="text" class="ce-editorjs-caption" value="${(this.data.caption || '').replace(/"/g, '&quot;')}"
                placeholder="Video caption (optional)"
                style="width: 100%; padding: 0.6rem 0.8rem; border: none; border-top: 1px solid var(--border);
                       background: var(--surface); color: var(--text); font-size: 0.85rem; outline: none; box-sizing: border-box;">`;
    }
    save(el) {
        const caption = el.querySelector('.ce-editorjs-caption');
        return {
            url: this.data.url,
            caption: caption ? caption.value : this.data.caption,
            poster: this.data.poster || '',
        };
    }
    validate(savedData) {
        return !!savedData.url;
    }
}

/**
 * AudioTool â€” Renders an audio player in the editor.
 * Data: { url, caption }
 */
class AudioTool {
    static get toolbox() {
        return { title: 'Audio', icon: '<svg width="17" height="15" viewBox="0 0 17 15"><circle cx="8.5" cy="7.5" r="6" stroke="currentColor" fill="none" stroke-width="1.5"/><path d="M8.5 4v7M6 6.5l2.5-2.5 2.5 2.5" stroke="currentColor" fill="none" stroke-width="1.5"/></svg>' };
    }
    constructor({ data, config, api }) {
        this.data = Object.assign({ url: '', caption: '' }, data);
        this.api = api;
        this.wrapper = null;
    }
    render() {
        this.wrapper = document.createElement('div');
        this.wrapper.style.cssText = 'border: 1px solid var(--border); border-radius: 8px; overflow: hidden; background: var(--surface);';
        this._renderContent();
        return this.wrapper;
    }
    _renderContent() {
        const url = this.data.url;
        const isPreview = url && (url.startsWith('/api/') || url.startsWith('http') || url.startsWith('blob:'));

        this.wrapper.innerHTML = `
            <div style="padding: 1rem; display: flex; align-items: center; gap: 1rem;">
                <div style="font-size: 2rem; opacity: 0.5;">ğŸµ</div>
                <div style="flex: 1;">
                    ${isPreview
                        ? `<audio controls preload="metadata" style="width: 100%;"><source src="${url}"></audio>`
                        : `<div style="color: var(--text-dim); font-size: 0.85rem;">
                            ${url ? url : 'No audio selected â€” use ğŸ“ Insert Media'}
                           </div>`
                    }
                </div>
            </div>
            <input type="text" class="ce-editorjs-caption" value="${(this.data.caption || '').replace(/"/g, '&quot;')}"
                placeholder="Audio caption (optional)"
                style="width: 100%; padding: 0.6rem 0.8rem; border: none; border-top: 1px solid var(--border);
                       background: var(--surface); color: var(--text); font-size: 0.85rem; outline: none; box-sizing: border-box;">`;
    }
    save(el) {
        const caption = el.querySelector('.ce-editorjs-caption');
        return {
            url: this.data.url,
            caption: caption ? caption.value : this.data.caption,
        };
    }
    validate(savedData) {
        return !!savedData.url;
    }
}

/**
 * AttachmentTool â€” Renders a download card in the editor.
 * Data: { url, title, size }
 */
class AttachmentTool {
    static get toolbox() {
        return { title: 'File', icon: '<svg width="17" height="15" viewBox="0 0 17 15"><path d="M4 1h6l4 4v9H4z" stroke="currentColor" fill="none" stroke-width="1.5"/><path d="M10 1v4h4" stroke="currentColor" fill="none" stroke-width="1.5"/></svg>' };
    }
    constructor({ data, config, api }) {
        this.data = Object.assign({ url: '', title: 'Attachment', size: 0 }, data);
        this.api = api;
        this.wrapper = null;
    }
    render() {
        this.wrapper = document.createElement('div');
        this.wrapper.style.cssText = 'border: 1px solid var(--border); border-radius: 8px; overflow: hidden; background: var(--surface);';
        this._renderContent();
        return this.wrapper;
    }
    _renderContent() {
        const url = this.data.url;
        const sizeStr = this.data.size ? formatMediaSize(this.data.size) : '';
        const isPreview = url && (url.startsWith('/api/') || url.startsWith('http'));

        this.wrapper.innerHTML = `
            <div style="padding: 1rem; display: flex; align-items: center; gap: 1rem;">
                <div style="font-size: 2rem; opacity: 0.5;">ğŸ“</div>
                <div style="flex: 1; min-width: 0;">
                    <input type="text" class="ce-editorjs-title" value="${(this.data.title || '').replace(/"/g, '&quot;')}"
                        placeholder="File name"
                        style="width: 100%; padding: 0.3rem 0; border: none; background: transparent;
                               color: var(--text); font-size: 0.9rem; font-weight: 500; outline: none;">
                    <div style="font-size: 0.78rem; color: var(--text-dim);">
                        ${sizeStr ? `${sizeStr} Â· ` : ''}${url
                            ? (isPreview
                                ? `<a href="${url}" target="_blank" style="color: var(--info);">Preview â†—</a>`
                                : `<span>${url}</span>`)
                            : 'No file selected â€” use ğŸ“ Insert Media'}
                    </div>
                </div>
            </div>`;
    }
    save(el) {
        const titleInput = el.querySelector('.ce-editorjs-title');
        return {
            url: this.data.url,
            title: titleInput ? titleInput.value : this.data.title,
            size: this.data.size,
        };
    }
    validate(savedData) {
        return !!savedData.url;
    }
}

// â”€â”€ Editor.js initialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function initContentEditor(data) {
// Destroy previous instance
if (contentEditor) {
try { contentEditor.destroy(); } catch (e) {}
contentEditor = null;
}

const holder = document.getElementById('content-editorjs');
holder.innerHTML = '';

// Check if EditorJS is loaded
if (typeof EditorJS === 'undefined') {
holder.innerHTML = `
<div style="padding: 1.5rem; text-align: center; color: var(--text-dim);">
    <p>â³ Loading Editor.js...</p>
    <p style="font-size: 0.78rem; margin-top: 0.5rem;">
        If this persists, check your internet connection (CDN-based).
    </p>
</div>`;
// Try loading scripts dynamically
await loadEditorScripts();
if (typeof EditorJS === 'undefined') {
holder.innerHTML = `
<div style="padding: 1.5rem; text-align: center; color: var(--danger);">
    âŒ Failed to load Editor.js from CDN. Check network connectivity.
</div>`;
return;
}
}

const toolConfig = {};

// Conditionally add tools based on what's available
if (typeof Header !== 'undefined') toolConfig.header = { class: Header, config: { levels: [1, 2, 3, 4], defaultLevel: 2
} };
if (typeof List !== 'undefined') toolConfig.list = { class: List };
if (typeof Quote !== 'undefined') toolConfig.quote = { class: Quote };
if (typeof CodeTool !== 'undefined') toolConfig.code = { class: CodeTool };
if (typeof Table !== 'undefined') toolConfig.table = { class: Table };
if (typeof Warning !== 'undefined') toolConfig.warning = { class: Warning };
if (typeof Delimiter !== 'undefined') toolConfig.delimiter = { class: Delimiter };

// Custom media tools (always available â€” defined above)
toolConfig.video = { class: VideoTool };
toolConfig.audio = { class: AudioTool };
toolConfig.attachment = { class: AttachmentTool };

// Image tool with hybrid upload (inline <100KB, vault â‰¥100KB)
if (typeof ImageTool !== 'undefined') {
toolConfig.image = {
    class: ImageTool,
    config: {
        uploader: {
            uploadByFile(file) {
                return new Promise((resolve, reject) => {
                    const formData = new FormData();
                    formData.append('image', file);

                    // Create floating progress toast
                    let toast = document.getElementById('editor-upload-toast');
                    if (!toast) {
                        toast = document.createElement('div');
                        toast.id = 'editor-upload-toast';
                        toast.style.cssText = `
                            position: fixed; bottom: 1.5rem; right: 1.5rem; z-index: 9999;
                            background: var(--surface, #1a1a2e); border: 1px solid var(--border, #333);
                            border-radius: 8px; padding: 0.75rem 1rem; min-width: 280px;
                            box-shadow: 0 4px 20px rgba(0,0,0,0.4); cursor: pointer;
                            font-size: 0.82rem; color: var(--text, #e0e0e0);
                        `;
                        toast.title = 'Click to cancel';
                        document.body.appendChild(toast);
                    }
                    toast.style.display = 'block';
                    toast.innerHTML = `
                        <div style="margin-bottom: 0.4rem; font-weight: 500;">ğŸ“¤ Uploading ${file.name}...</div>
                        <div style="height: 4px; background: var(--surface-alt, #2a2a3a); border-radius: 2px; overflow: hidden;">
                            <div id="editor-upload-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), #60a5fa); transition: width 0.2s;"></div>
                        </div>
                        <div id="editor-upload-detail" style="font-size: 0.72rem; color: var(--text-dim); margin-top: 0.3rem;">0%</div>
                    `;

                    const xhr = new XMLHttpRequest();
                    const startTime = Date.now();

                    toast.onclick = () => {
                        xhr.abort();
                        toast.style.display = 'none';
                        contentLog('âš ï¸ Editor image upload cancelled');
                        reject(new Error('Upload cancelled'));
                    };

                    xhr.upload.addEventListener('progress', (e) => {
                        if (!e.lengthComputable) return;
                        const pct = Math.round((e.loaded / e.total) * 100);
                        const bar = document.getElementById('editor-upload-bar');
                        const detail = document.getElementById('editor-upload-detail');
                        if (bar) bar.style.width = pct + '%';
                        const elapsed = (Date.now() - startTime) / 1000;
                        const speed = e.loaded / elapsed;
                        const speedStr = speed > 1024*1024
                            ? `${(speed/(1024*1024)).toFixed(1)} MB/s`
                            : `${(speed/1024).toFixed(0)} KB/s`;
                        if (detail) detail.textContent = `${pct}% Â· ${speedStr}`;
                    });

                    xhr.upload.addEventListener('loadend', () => {
                        const bar = document.getElementById('editor-upload-bar');
                        const detail = document.getElementById('editor-upload-detail');
                        if (detail) detail.textContent = 'âš™ï¸ Optimizing...';
                        // Interpolate optimization progress
                        let optPct = 0;
                        window._editorOptInterval = setInterval(() => {
                            optPct = Math.min(90, optPct + 3);
                            if (bar) bar.style.width = optPct + '%';
                        }, 200);
                    });

                    xhr.addEventListener('load', () => {
                        if (window._editorOptInterval) clearInterval(window._editorOptInterval);
                        const bar = document.getElementById('editor-upload-bar');
                        if (bar) bar.style.width = '100%';
                        if (xhr.status >= 200 && xhr.status < 300) {
                            try {
                                const data = JSON.parse(xhr.responseText);
                                if (data.success) {
                                    if (bar) bar.style.background = 'linear-gradient(90deg, #22c55e, #4ade80)';
                                    if (data.inline) {
                                        contentLog(`ğŸ–¼ï¸ Image inlined (${formatMediaSize(data.size_bytes)})`);
                                    } else {
                                        const opt = data.optimized
                                            ? ` Â· optimized ${formatMediaSize(data.original_size_bytes)} â†’ ${formatMediaSize(data.size_bytes)}`
                                            : '';
                                        const tier = data.storage === 'large' ? ' [release]' : '';
                                        contentLog(`ğŸ–¼ï¸ Image â†’ vault: ${data.media_id} (${formatMediaSize(data.size_bytes)}${opt}${tier})`);
                                    }
                                    setTimeout(() => { toast.style.display = 'none'; }, 1500);
                                    resolve(data);
                                } else {
                                    contentLog(`âŒ Image upload failed: ${data.error}`, true);
                                    toast.style.display = 'none';
                                    reject(new Error(data.error));
                                }
                            } catch (e) {
                                toast.style.display = 'none';
                                contentLog('âŒ Editor upload: invalid server response', true);
                                reject(new Error('Invalid server response'));
                            }
                        } else {
                            // Error response â€” try to parse structured JSON error
                            let errMsg = `Server error (HTTP ${xhr.status})`;
                            try {
                                const errData = JSON.parse(xhr.responseText);
                                errMsg = errData.error || errMsg;
                            } catch (e) {
                                if (xhr.responseText?.includes('Internal Server Error')) {
                                    errMsg = `Server crashed (HTTP ${xhr.status}) â€” check logs`;
                                }
                            }
                            // Show error in toast briefly
                            const bar = document.getElementById('editor-upload-bar');
                            if (bar) bar.style.background = 'var(--danger, #ef4444)';
                            const detail = document.getElementById('editor-upload-detail');
                            if (detail) detail.textContent = `âŒ ${errMsg}`;
                            contentLog(`âŒ Editor upload: ${errMsg}`, true);
                            setTimeout(() => { toast.style.display = 'none'; }, 4000);
                            reject(new Error(errMsg));
                        }
                    });

                    xhr.addEventListener('error', () => {
                        if (window._editorOptInterval) clearInterval(window._editorOptInterval);
                        const bar = document.getElementById('editor-upload-bar');
                        if (bar) bar.style.background = 'var(--danger, #ef4444)';
                        toast.innerHTML += '<div style="color: var(--danger); margin-top: 0.3rem;">Network error</div>';
                        contentLog('âŒ Editor upload network error', true);
                        setTimeout(() => { toast.style.display = 'none'; }, 3000);
                        reject(new Error('Network error'));
                    });

                    xhr.addEventListener('abort', () => {
                        if (window._editorOptInterval) clearInterval(window._editorOptInterval);
                    });

                    xhr.open('POST', '/api/content/media/editor-upload');
                    xhr.timeout = 300000; // 5 min for images
                    xhr.send(formData);
                });
            },
            async uploadByUrl(url) {
                const resp = await fetch('/api/content/media/editor-fetch-url', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url }),
                });
                return await resp.json();
            },
        },
        // In admin preview, resolve media:// URIs to preview endpoint
        actions: [],
    },
};
}

// â”€â”€ EditorJS instantiation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let contentEditorReady = false;

contentEditor = new EditorJS({
holder: 'content-editorjs',
data: data,
tools: toolConfig,
placeholder: 'Start writing your article...',
onChange: () => {
    // Ignore onChange events fired during editor initialization
    if (!contentEditorReady) return;
    contentDirty = true;
    const statusEl = document.getElementById('content-save-status');
    if (statusEl) statusEl.style.opacity = '0';
},
minHeight: 300,
});

try {
await contentEditor.isReady;
// Wait for images to load â€” they fire onChange when they render
setTimeout(() => {
    contentEditorReady = true;
    contentDirty = false;  // Clear any false positives from image loads
}, 1500);
} catch (e) {
console.warn('Editor.js ready warning:', e);
contentEditorReady = true;
}
}

// â”€â”€ Lazy-load Editor.js scripts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let editorScriptsLoaded = false;

function loadScript(src) {
return new Promise((resolve, reject) => {
const script = document.createElement('script');
script.src = src;
script.onload = resolve;
script.onerror = reject;
document.head.appendChild(script);
});
}

async function loadEditorScripts() {
if (editorScriptsLoaded) return;
const cdn = 'https://cdn.jsdelivr.net/npm';
try {
await loadScript(`${cdn}/@editorjs/editorjs@2.30/dist/editorjs.umd.min.js`);
// Load tools in parallel
await Promise.allSettled([
loadScript(`${cdn}/@editorjs/header@2.8/dist/header.umd.min.js`),
loadScript(`${cdn}/@editorjs/list@1.9/dist/list.umd.min.js`),
loadScript(`${cdn}/@editorjs/image@2.9/dist/image.umd.min.js`),

loadScript(`${cdn}/@editorjs/quote@2.7/dist/quote.umd.min.js`),
loadScript(`${cdn}/@editorjs/code@2.9/dist/code.umd.min.js`),
loadScript(`${cdn}/@editorjs/table@2.4/dist/table.umd.min.js`),
loadScript(`${cdn}/@editorjs/warning@1.4/dist/warning.umd.min.js`),
loadScript(`${cdn}/@editorjs/delimiter@1.4/dist/delimiter.umd.min.js`),
]);
editorScriptsLoaded = true;
} catch (e) {
console.error('Failed to load Editor.js scripts:', e);
}
}

// â”€â”€ Save article â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentSave() {
if (!contentEditor || !contentSelectedSlug) return;

const saveBtn = document.getElementById('content-save-btn');
saveBtn.disabled = true;
saveBtn.textContent = 'â³ Saving...';

try {
const rawOutputData = await contentEditor.save();
const outputData = contentRewriteMediaUrls(rawOutputData, 'toMedia');
const encrypt = document.getElementById('content-encrypt-toggle').checked;

if (encrypt && !contentEncryptionAvailable) {
contentLog('âš ï¸ Cannot encrypt â€” CONTENT_ENCRYPTION_KEY is not set.\nGo to Secrets â†’ Security to configure it.', true);
return;
}

const resp = await fetch(`/api/content/articles/${contentSelectedSlug}`, {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                content: outputData,
                encrypt: encrypt,
                metadata: {
                    min_stage: document.getElementById('content-meta-stage').value,
                    include_in_nav: document.getElementById('content-meta-nav').checked,
                    pin_to_top: document.getElementById('content-meta-pin').checked,
                },
            }),
});
const data = await resp.json();

if (data.success) {
contentDirty = false;
contentOriginalData = outputData;
const encLabel = data.encrypted ? 'ğŸ”’ encrypted' : 'ğŸ“„ plaintext';
contentLog(`âœ… Saved "${contentSelectedSlug}" as ${encLabel}`);
if (data.media_reconciled > 0) {
    contentLog(`ğŸ”„ ${data.media_reconciled} media file(s) updated to match`);
}
// Show save status
const statusEl = document.getElementById('content-save-status');
if (statusEl) {
    statusEl.textContent = 'âœ… Saved Â· Sync to publish';
    statusEl.style.opacity = '1';
}
// Refresh list to update badges
await loadContent();
renderContentList();
// Invalidate media cache so panel shows updated refs/captions
mediaLoaded = false;
} else {
contentLog(`âŒ Save failed: ${data.error}`, true);
}
} catch (error) {
contentLog(`âŒ Save error: ${error.message}`, true);
} finally {
saveBtn.disabled = false;
saveBtn.textContent = 'ğŸ’¾ Save';
}
}

// â”€â”€ Discard changes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentDiscard() {
if (!contentDirty) return;
if (!confirm('Discard all changes?')) return;
contentDirty = false;
if (contentOriginalData) {
await initContentEditor(contentOriginalData);
}
contentLog('â†©ï¸ Changes discarded.');
}

// â”€â”€ New article â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentNewArticle() {
const slug = prompt('Article slug (lowercase, underscores):', '');
if (!slug) return;

// Validate slug
const clean = slug.trim().toLowerCase().replace(/[^a-z0-9_]/g, '_').replace(/_+/g, '_');
if (!clean) {
alert('Invalid slug. Use lowercase letters, numbers, and underscores.');
return;
}

// Check if already exists
if (contentArticles.some(a => a.slug === clean)) {
alert(`Article "${clean}" already exists. Select it from the list.`);
return;
}

// Create default content
const defaultContent = {
time: Date.now(),
blocks: [
{ type: 'header', data: { text: clean.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()), level: 1 } },
{ type: 'paragraph', data: { text: '' } },
],
version: '2.28.0',
};

try {
const resp = await fetch(`/api/content/articles/${clean}`, {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({ content: defaultContent, encrypt: false }),
});
const data = await resp.json();
if (data.success) {
contentLog(`âœ… Created article "${clean}"`);
await loadContent();
contentSelectArticle(clean);
} else {
contentLog(`âŒ Failed: ${data.error}`, true);
}
} catch (error) {
contentLog(`âŒ Error: ${error.message}`, true);
}
}

// â”€â”€ Delete article â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentDeleteArticle() {
if (!contentSelectedSlug) return;
if (!confirm(`Permanently delete "${contentSelectedSlug}"? This cannot be undone.`)) return;

try {
const resp = await fetch(`/api/content/articles/${contentSelectedSlug}`, {
    method: 'DELETE',
});
const data = await resp.json();
if (data.success) {
    contentLog(`ğŸ—‘ï¸ Deleted "${contentSelectedSlug}"`);

    // Offer to delete orphaned media
    if (data.orphaned_media && data.orphaned_media.length > 0) {
        const names = data.orphaned_media.map(m => `  â€¢ ${m.original_name} (${m.id})`).join('\n');
        if (confirm(`${data.orphaned_media.length} media file(s) are no longer referenced by any article:\n\n${names}\n\nDelete them?`)) {
            for (const m of data.orphaned_media) {
                try {
                    const delResp = await fetch(`/api/content/media/${m.id}`, { method: 'DELETE' });
                    const delData = await delResp.json();
                    if (delData.success) {
                        contentLog(`ğŸ—‘ï¸ Deleted orphaned media: ${m.original_name}`);
                    }
                } catch (e) {
                    contentLog(`âŒ Failed to delete ${m.id}: ${e.message}`, true);
                }
            }
            mediaLoaded = false;
        }
    }

    contentSelectedSlug = null;
    contentDirty = false;
    resetContentEditor();
    await loadContent();
} else {
    contentLog(`âŒ Delete failed: ${data.error}`, true);
}
} catch (error) {
contentLog(`âŒ Error: ${error.message}`, true);
}
}

// â”€â”€ Encrypt / decrypt in-place â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentEncryptInPlace() {
if (!contentSelectedSlug) return;
const art = contentArticles.find(a => a.slug === contentSelectedSlug);
if (!art) return;

if (art.encrypted) {
// Decrypt
try {
const resp = await fetch(`/api/content/articles/${contentSelectedSlug}/decrypt`, { method: 'POST' });
const data = await resp.json();
if (data.success) {
contentLog(`ğŸ”“ Decrypted "${contentSelectedSlug}" â€” now stored as plaintext`);
await loadContent();
contentSelectArticle(contentSelectedSlug);
} else {
contentLog(`âŒ ${data.error}`, true);
}
} catch (e) {
contentLog(`âŒ Error: ${e.message}`, true);
}
} else {
// Encrypt
if (!contentEncryptionAvailable) {
contentLog('âš ï¸ Cannot encrypt â€” CONTENT_ENCRYPTION_KEY is not set.', true);
return;
}
try {
const resp = await fetch(`/api/content/articles/${contentSelectedSlug}/encrypt`, { method: 'POST' });
const data = await resp.json();
if (data.success) {
contentLog(`ğŸ”’ Encrypted "${contentSelectedSlug}" â€” now stored encrypted in repo`);
await loadContent();
contentSelectArticle(contentSelectedSlug);
} else {
contentLog(`âŒ ${data.error}`, true);
}
} catch (e) {
contentLog(`âŒ Error: ${e.message}`, true);
}
}
}

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function resetContentEditor() {
document.getElementById('content-editor-slug').textContent = 'Select an article';
document.getElementById('content-editor-badges').innerHTML = '';
document.getElementById('content-editor-empty').style.display = 'flex';
document.getElementById('content-editorjs-wrap').style.display = 'none';
document.getElementById('content-editor-controls').style.display = 'none';
document.getElementById('content-meta-panel').style.display = 'none';
if (contentEditor) {
try { contentEditor.destroy(); } catch (e) {}
contentEditor = null;
}
}

function updateEncryptNote() {
const note = document.getElementById('content-encrypt-note');
const checked = document.getElementById('content-encrypt-toggle').checked;
if (checked && !contentEncryptionAvailable) {
note.innerHTML = '<span style="color: var(--danger);">âš ï¸ Key not set â€” encryption will fail</span>';
} else if (checked) {
note.textContent = 'Content will be encrypted before saving to disk';
} else {
note.textContent = 'Content will be saved as plaintext';
}
}

// Attach toggle listener
document.getElementById('content-encrypt-toggle')?.addEventListener('change', updateEncryptNote);

function contentLog(message, isError = false) {
const terminal = document.getElementById('content-terminal');
const timestamp = new Date().toLocaleTimeString();
if (isError) {
terminal.className = 'terminal error';
} else {
terminal.className = 'terminal';
}
terminal.textContent = `[${timestamp}] ${message}`;
}

// â”€â”€ Media URL rewriting for Editor.js â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const MEDIA_URI_PREFIX = 'media://';
const MEDIA_PREVIEW_PREFIX = '/api/content/media/';

/**
 * Rewrite media:// URIs â†” preview endpoint URLs in Editor.js data.
 *
 * Handles all media block types:
 *   image:      data.file.url
 *   video:      data.url, data.poster
 *   audio:      data.url
 *   attachment:  data.url
 *
 * @param {Object} editorData - Editor.js output data (with blocks array)
 * @param {string} direction - 'toPreview' or 'toMedia'
 * @returns {Object} Deep clone with rewritten URLs
 */
function contentRewriteMediaUrls(editorData, direction) {
    if (!editorData || !editorData.blocks) return editorData;
    
    // Deep clone so we don't mutate the original
    const clone = JSON.parse(JSON.stringify(editorData));
    
    function rewriteUrl(url) {
        if (!url) return url;
        if (direction === 'toPreview' && url.startsWith(MEDIA_URI_PREFIX)) {
            const mediaId = url.slice(MEDIA_URI_PREFIX.length);
            return `${MEDIA_PREVIEW_PREFIX}${mediaId}/preview`;
        } else if (direction === 'toMedia' && url.startsWith(MEDIA_PREVIEW_PREFIX)) {
            const match = url.match(/^\/api\/content\/media\/([^/]+)\/preview$/);
            if (match) return `${MEDIA_URI_PREFIX}${match[1]}`;
        }
        return url; // data: and https:// pass through unchanged
    }

    for (const block of clone.blocks) {
        const d = block.data;
        if (!d) continue;

        switch (block.type) {
            case 'image':
                // EditorJS Image tool: data.file.url
                if (d.file && d.file.url) d.file.url = rewriteUrl(d.file.url);
                // Legacy flat format fallback
                else if (d.url) d.url = rewriteUrl(d.url);
                break;
            case 'video':
                if (d.url) d.url = rewriteUrl(d.url);
                if (d.poster) d.poster = rewriteUrl(d.poster);
                break;
            case 'audio':
                if (d.url) d.url = rewriteUrl(d.url);
                break;
            case 'attachment':
                if (d.url) d.url = rewriteUrl(d.url);
                break;
        }
    }
    
    return clone;
}

// formatMediaSize is used by both _content.html and _media.html
if (typeof formatMediaSize === 'undefined') {
function formatMediaSize(bytes) {
    if (bytes === 0) return '0 B';
    const units = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    const val = (bytes / Math.pow(1024, i)).toFixed(i === 0 ? 0 : 1);
    return `${val} ${units[i]}`;
}
}

// â”€â”€ Vault Picker Modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let vaultPickerEntries = [];
let vaultPickerSelected = null;  // MediaEntry object
let vaultPickerCurrentFilter = 'all';
let vaultPickerTarget = 'editor';  // 'editor' (EditorJS) or 'messages' (textarea)

function _vaultPickerMimeCategory(mime) {
    if (!mime) return 'file';
    if (mime.startsWith('image/')) return 'image';
    if (mime.startsWith('video/')) return 'video';
    if (mime.startsWith('audio/')) return 'audio';
    return 'file';
}

async function openVaultPicker() {
    vaultPickerSelected = null;
    vaultPickerCurrentFilter = 'all';

    // Reset tab active state
    document.querySelectorAll('.vault-picker-tab').forEach(t => t.classList.remove('active'));
    document.querySelector('.vault-picker-tab[data-filter="all"]').classList.add('active');

    // Show modal
    document.getElementById('vault-picker-overlay').style.display = 'flex';
    document.getElementById('vault-picker-actions').style.display = 'none';
    document.getElementById('vault-picker-status').textContent = '';

    // Fetch media entries
    const grid = document.getElementById('vault-picker-grid');
    grid.innerHTML = '<div class="loading">Loading media</div>';

    try {
        const resp = await fetch('/api/content/media');
        const data = await resp.json();
        vaultPickerEntries = data.media || [];
        _renderVaultPickerGrid();
    } catch (error) {
        grid.innerHTML = `<div class="vault-picker-empty">âŒ Failed to load media: ${error.message}</div>`;
    }
}

function closeVaultPicker(event) {
    // If called from overlay click, only close if clicking the overlay itself
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('vault-picker-overlay').style.display = 'none';
    document.getElementById('vault-picker-file-input').value = '';
    vaultPickerSelected = null;
    vaultPickerTarget = 'editor';  // Reset to default mode
}

function vaultPickerFilter(filter, btn) {
    vaultPickerCurrentFilter = filter;
    vaultPickerSelected = null;
    document.getElementById('vault-picker-actions').style.display = 'none';

    document.querySelectorAll('.vault-picker-tab').forEach(t => t.classList.remove('active'));
    btn.classList.add('active');

    _renderVaultPickerGrid();
}

function _renderVaultPickerGrid() {
    const grid = document.getElementById('vault-picker-grid');

    const filtered = vaultPickerCurrentFilter === 'all'
        ? vaultPickerEntries
        : vaultPickerEntries.filter(e => _vaultPickerMimeCategory(e.mime_type) === vaultPickerCurrentFilter);

    if (filtered.length === 0) {
        grid.innerHTML = `<div class="vault-picker-empty">
            ${vaultPickerEntries.length === 0
                ? 'No media files yet â€” upload one below'
                : 'No matching files in this category'}
        </div>`;
        return;
    }

    let html = '';
    for (const item of filtered) {
        const isSelected = vaultPickerSelected && vaultPickerSelected.id === item.id;
        const isImage = item.mime_type?.startsWith('image/');
        const icon = typeof getMediaIcon !== 'undefined' ? getMediaIcon(item.mime_type) : 'ğŸ“';

        html += `
        <div class="vault-picker-item ${isSelected ? 'selected' : ''}"
             onclick="vaultPickerSelect('${item.id}')"
             title="${item.original_name}\n${item.mime_type} Â· ${formatMediaSize(item.size_bytes)}">
            <div class="vault-picker-thumb">
                ${isImage
                    ? `<img src="/api/content/media/${item.id}/preview" alt="${item.original_name}" loading="lazy"
                        onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                       <div style="display: none; align-items: center; justify-content: center; width: 100%; height: 100%; font-size: 1.5rem; opacity: 0.4;">ğŸ”’</div>`
                    : `<div style="font-size: 1.8rem; opacity: 0.5;">${icon}</div>`
                }
            </div>
            <div class="vault-picker-label">${item.original_name}</div>
        </div>`;
    }

    grid.innerHTML = html;
}

function vaultPickerSelect(mediaId) {
    const item = vaultPickerEntries.find(e => e.id === mediaId);
    if (!item) return;

    vaultPickerSelected = item;
    _renderVaultPickerGrid();

    // Show action buttons
    const actions = document.getElementById('vault-picker-actions');
    actions.style.display = 'flex';

    // Determine if embed is possible (only for image/video/audio)
    const cat = _vaultPickerMimeCategory(item.mime_type);
    const canEmbed = ['image', 'video', 'audio'].includes(cat);

    const embedBtn = document.getElementById('vault-picker-embed-btn');
    const attachBtn = document.getElementById('vault-picker-attach-btn');
    embedBtn.style.display = canEmbed ? '' : 'none';
    embedBtn.disabled = false;
    embedBtn.title = '';

    // Remove any previous MMS warning
    const prevWarn = document.getElementById('vault-picker-mms-warning');
    if (prevWarn) prevWarn.remove();

    // â”€â”€ SMS MMS compatibility check â”€â”€
    // When inserting into an SMS message, only certain image types work as MMS.
    // webp, svg, etc. are rejected by Twilio/carriers with error 12300.
    if (vaultPickerTarget === 'messages') {
        const adapter = document.getElementById('messages-edit-adapter')?.value;
        if (adapter === 'sms' && cat === 'image') {
            const MMS_SAFE_TYPES = [
                'image/jpeg', 'image/png', 'image/gif',
                'image/bmp', 'image/tiff',
            ];
            const isMmsSafe = MMS_SAFE_TYPES.includes(item.mime_type);

            if (!isMmsSafe) {
                // Block the embed button (MMS attachment)
                embedBtn.disabled = true;
                embedBtn.title = `${item.mime_type} is not supported for MMS`;
                embedBtn.style.opacity = '0.4';

                // Show warning inline with action buttons
                const warn = document.createElement('div');
                warn.id = 'vault-picker-mms-warning';
                warn.style.cssText = `
                    font-size: 0.78rem; color: #f59e0b;
                    padding: 0.4rem 0.65rem; background: rgba(245,158,11,0.1);
                    border: 1px solid rgba(245,158,11,0.25); border-radius: 6px;
                    line-height: 1.3; flex: 1;
                `;
                warn.innerHTML = `
                    âš ï¸ <strong>${item.mime_type}</strong> not supported for MMS â€”
                    use <strong>ğŸ“ Attach</strong> (URL in body)
                `;
                actions.insertBefore(warn, actions.firstChild);
            } else {
                embedBtn.style.opacity = '';
            }
        }
    }

    // Update status
    document.getElementById('vault-picker-status').textContent =
        `Selected: ${item.original_name} (${formatMediaSize(item.size_bytes)})`;
}

function vaultPickerInsert(mode) {
    if (!vaultPickerSelected) return;

    const item = vaultPickerSelected;
    const cat = _vaultPickerMimeCategory(item.mime_type);
    const mediaUri = `media://${item.id}`;

    // â”€â”€ Messages mode: insert markdown syntax into textarea â”€â”€
    if (vaultPickerTarget === 'messages') {
        let altPrefix = '';
        let emoji = 'ğŸ“¸';
        if (cat === 'video')       { altPrefix = 'video: '; emoji = 'ğŸ¬'; }
        else if (cat === 'audio')  { altPrefix = 'audio: '; emoji = 'ğŸµ'; }
        else if (cat === 'file' || mode === 'attach') { altPrefix = 'file: '; emoji = 'ğŸ“'; }

        const name = item.caption || item.original_name;
        const markdownSnippet = `![${altPrefix}${name}](${mediaUri})`;

        // Delegate insertion to messages script
        if (typeof messagesInsertMedia === 'function') {
            messagesInsertMedia(markdownSnippet);
        }

        contentLog(`âœ… Inserted ${emoji} ${item.original_name} as markdown`);
        closeVaultPicker();
        return;
    }

    // â”€â”€ Editor mode: insert EditorJS block â”€â”€
    if (!contentEditor) return;

    const previewUrl = `/api/content/media/${item.id}/preview`;

    let blockType, blockData;

    if (mode === 'attach') {
        blockType = 'attachment';
        blockData = {
            url: previewUrl,
            title: item.original_name,
            size: item.size_bytes,
        };
    } else {
        // Embed
        switch (cat) {
            case 'image':
                blockType = 'image';
                blockData = {
                    file: { url: previewUrl },
                    caption: item.caption || '',
                    stretched: false,
                    withBorder: false,
                    withBackground: false,
                };
                break;
            case 'video':
                blockType = 'video';
                blockData = {
                    url: previewUrl,
                    caption: item.caption || item.original_name,
                    poster: '',
                };
                break;
            case 'audio':
                blockType = 'audio';
                blockData = {
                    url: previewUrl,
                    caption: item.caption || item.original_name,
                };
                break;
            default:
                // Shouldn't reach here since embed is hidden for non-media
                blockType = 'attachment';
                blockData = { url: previewUrl, title: item.original_name, size: item.size_bytes };
        }
    }

    // Insert the block at the end of the editor
    contentEditor.blocks.insert(blockType, blockData);
    contentDirty = true;

    const modeLabel = mode === 'attach' ? 'ğŸ“ attached' : 'â–¶ embedded';
    contentLog(`âœ… Inserted ${item.original_name} as ${blockType} (${modeLabel})`);

    closeVaultPicker();
}

async function vaultPickerUploadFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const status = document.getElementById('vault-picker-status');
    status.textContent = `â³ Uploading ${file.name}...`;

    const formData = new FormData();
    formData.append('file', file);
    formData.append('min_stage', 'FULL');

    try {
        const resp = await fetch('/api/content/media/upload', {
            method: 'POST',
            body: formData,
        });
        const data = await resp.json();

        if (data.success) {
            status.textContent = `âœ… Uploaded: ${data.original_name}`;

            // Refresh and select the new entry
            const resp2 = await fetch('/api/content/media');
            const data2 = await resp2.json();
            vaultPickerEntries = data2.media || [];

            // Auto-select the uploaded file
            vaultPickerSelected = vaultPickerEntries.find(e => e.id === data.id) || null;
            _renderVaultPickerGrid();
            if (vaultPickerSelected) vaultPickerSelect(data.id);

            // Invalidate media panel cache
            mediaLoaded = false;
        } else {
            status.textContent = `âŒ Upload failed: ${data.error}`;
        }
    } catch (error) {
        status.textContent = `âŒ Upload error: ${error.message}`;
    }

    // Reset file input
    document.getElementById('vault-picker-file-input').value = '';
}

// Close vault picker on Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && document.getElementById('vault-picker-overlay').style.display !== 'none') {
        closeVaultPicker();
    }
});