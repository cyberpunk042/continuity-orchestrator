// ========================================
// CONTENT TAB
// ========================================

let contentLoaded = false;
let contentArticles = [];
let contentSelectedSlug = null;
let contentEditor = null;
let contentEncryptionAvailable = false;
let contentOriginalData = null; // For dirty tracking
let contentDirty = false;

// â”€â”€ Load content data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function loadContent() {
try {
// Load articles list
const resp = await fetch('/api/content/articles');
const data = await resp.json();
contentArticles = data.articles || [];
contentEncryptionAvailable = data.encryption_available;

renderContentKeyBar();
renderContentList();
contentLoaded = true;
} catch (error) {
document.getElementById('content-article-list').innerHTML =
`<div style="color: var(--danger); font-size: 0.85rem;">âŒ Failed to load: ${error.message}</div>`;
}
}

// â”€â”€ Encryption key status bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderContentKeyBar() {
const el = document.getElementById('content-key-status');
if (contentEncryptionAvailable) {
el.innerHTML = `
<span style="color: var(--accent);">ğŸ”‘ Encryption key: âœ… Configured</span>`;
document.getElementById('content-gen-key-btn').style.display = 'none';
} else {
el.innerHTML = `
<span style="color: var(--warning);">ğŸ”‘ Encryption key: âš ï¸ Not set</span>
<span style="font-size: 0.78rem; color: var(--text-dim);">
    â€” set via <a href="#secrets" onclick="switchTab('secrets'); return false;" style="color: var(--info);">Secrets</a>
    or <a href="#wizard/security" onclick="goToWizardStep('security'); return false;"
        style="color: var(--info);">Wizard</a>
</span>`;
document.getElementById('content-gen-key-btn').style.display = '';
}
}

async function contentGenerateKey() {
try {
const response = await fetch('/api/content/keygen', { method: 'POST' });
const data = await response.json();
if (data.error) {
contentLog(`âŒ Failed to generate key: ${data.error}`, true);
return;
}
// Show the key and guide user to save it
contentLog(
`ğŸ”‘ Generated key:\n\n ${data.key}\n\n` +
`âš ï¸ This key is NOT saved yet!\n` +
`Go to ğŸ” Secrets â†’ Security â†’ CONTENT_ENCRYPTION_KEY\n` +
`and paste it there, then Save & Push.`
);
// Also copy to clipboard
try {
await navigator.clipboard.writeText(data.key);
contentLog(`\nğŸ“‹ Key copied to clipboard.`);
} catch (e) { /* clipboard not available */ }
} catch (error) {
contentLog(`âŒ Error: ${error.message}`, true);
}
}

// â”€â”€ Article list â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderContentList() {
const el = document.getElementById('content-article-list');

if (contentArticles.length === 0) {
el.innerHTML = `
<div style="text-align: center; padding: 1.5rem 0; color: var(--text-dim);">
    <div style="font-size: 2rem; margin-bottom: 0.5rem; opacity: 0.3;">ğŸ“„</div>
    <p style="font-size: 0.85rem;">No articles yet</p>
    <button class="btn primary" onclick="contentNewArticle()" style="margin-top: 0.75rem; font-size: 0.82rem;">
        â• Create your first article
    </button>
</div>`;
return;
}

let html = '<div style="display: flex; flex-direction: column; gap: 0.25rem;">';
    for (const art of contentArticles) {
    const isSelected = art.slug === contentSelectedSlug;
    const icon = art.encrypted ? 'ğŸ”’' : 'ğŸ“„';
    const stageColor = {
    'OK': 'var(--accent)',
    'WARNING': 'var(--warning)',
    'CRITICAL': 'var(--danger)',
    'FINAL': 'var(--danger)',
    'FULL': 'var(--danger)',
    }[art.min_stage] || 'var(--text-dim)';

    html += `
    <div onclick="contentSelectArticle('${art.slug}')" class="content-article-row ${isSelected ? 'selected' : ''}"
        style="display: flex; align-items: center; gap: 0.6rem; padding: 0.6rem 0.75rem;
                                border-radius: 8px; cursor: pointer; transition: all 0.15s;
                                background: ${isSelected ? 'var(--accent-dim)' : 'transparent'};
                                border: 1px solid ${isSelected ? 'rgba(74,222,128,0.3)' : 'transparent'};">
        <span style="font-size: 1.1rem;">${icon}</span>
        <div style="flex: 1; min-width: 0;">
            <div translate="no" style="font-size: 0.88rem; font-weight: ${isSelected ? '600' : '500'}; 
                                        color: ${isSelected ? 'var(--accent)' : 'var(--text)'}; 
                                        white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                ${art.title}
            </div>
            <div translate="no" style="font-size: 0.72rem; color: var(--text-dim); margin-top: 0.1rem;">
                ${art.slug}
            </div>
        </div>
        ${art.min_stage ? `<span translate="no" style="font-size: 0.68rem; padding: 0.1rem 0.4rem; border-radius: 4px;
                            background: ${stageColor}22; color: ${stageColor}; font-weight: 500;">
            ${art.min_stage}</span>` : ''}
    </div>`;
    }
    html += '</div>';
el.innerHTML = html;
}

// â”€â”€ Select article â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentSelectArticle(slug) {
// Warn if dirty
if (contentDirty && contentSelectedSlug) {
if (!confirm('You have unsaved changes. Discard and switch article?')) return;
}

contentSelectedSlug = slug;
contentDirty = false;
contentEditorReady = false;
const statusEl = document.getElementById('content-save-status');
if (statusEl) statusEl.style.opacity = '0';
renderContentList();

// Show loading state in editor
document.getElementById('content-editor-slug').textContent = slug;
document.getElementById('content-editor-empty').style.display = 'none';
document.getElementById('content-editorjs-wrap').style.display = 'block';
document.getElementById('content-editor-controls').style.display = 'block';
document.getElementById('content-meta-panel').style.display = 'block';
document.getElementById('content-editorjs').innerHTML = '<div class="loading">Loading article</div>';

try {
const resp = await fetch(`/api/content/articles/${slug}`);
const data = await resp.json();

if (data.error) {
document.getElementById('content-editorjs').innerHTML =
`<div style="padding: 1rem; color: var(--danger); font-size: 0.9rem;">
    âš ï¸ ${data.error}
</div>`;
return;
}

// Update badges
const badges = document.getElementById('content-editor-badges');
badges.innerHTML = '';
if (data.encrypted) {
badges.innerHTML += '<span class="badge warning" style="font-size: 0.72rem; padding: 0.15rem 0.5rem;">ğŸ”’ Encrypted</span>';
}

// Set encryption toggle
const encToggle = document.getElementById('content-encrypt-toggle');
encToggle.checked = !!data.encrypted;
updateEncryptNote();

// Set metadata fields
if (data.manifest_entry) {
const me = data.manifest_entry;
document.getElementById('content-meta-stage').value = me.min_stage || 'FULL';
document.getElementById('content-meta-nav').checked = me.include_in_nav !== false;
document.getElementById('content-meta-pin').checked = !!me.pin_to_top;
}

// Initialize Editor.js â€” rewrite media:// URIs for preview
contentOriginalData = data.content;
const editorData = contentRewriteMediaUrls(data.content, 'toPreview');
await initContentEditor(editorData);

} catch (error) {
document.getElementById('content-editorjs').innerHTML =
`<div style="padding: 1rem; color: var(--danger);">âŒ Failed to load: ${error.message}</div>`;
}
}

// â”€â”€ Editor.js initialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function initContentEditor(data) {
// Destroy previous instance
if (contentEditor) {
try { contentEditor.destroy(); } catch (e) {}
contentEditor = null;
}

const holder = document.getElementById('content-editorjs');
holder.innerHTML = '';

// Check if EditorJS is loaded
if (typeof EditorJS === 'undefined') {
holder.innerHTML = `
<div style="padding: 1.5rem; text-align: center; color: var(--text-dim);">
    <p>â³ Loading Editor.js...</p>
    <p style="font-size: 0.78rem; margin-top: 0.5rem;">
        If this persists, check your internet connection (CDN-based).
    </p>
</div>`;
// Try loading scripts dynamically
await loadEditorScripts();
if (typeof EditorJS === 'undefined') {
holder.innerHTML = `
<div style="padding: 1.5rem; text-align: center; color: var(--danger);">
    âŒ Failed to load Editor.js from CDN. Check network connectivity.
</div>`;
return;
}
}

const toolConfig = {};

// Conditionally add tools based on what's available
if (typeof Header !== 'undefined') toolConfig.header = { class: Header, config: { levels: [1, 2, 3, 4], defaultLevel: 2
} };
if (typeof List !== 'undefined') toolConfig.list = { class: List };
if (typeof Quote !== 'undefined') toolConfig.quote = { class: Quote };
if (typeof CodeTool !== 'undefined') toolConfig.code = { class: CodeTool };
if (typeof Table !== 'undefined') toolConfig.table = { class: Table };
if (typeof Warning !== 'undefined') toolConfig.warning = { class: Warning };
if (typeof Delimiter !== 'undefined') toolConfig.delimiter = { class: Delimiter };

// Image tool with hybrid upload (inline <100KB, vault â‰¥100KB)
if (typeof ImageTool !== 'undefined') {
toolConfig.image = {
    class: ImageTool,
    config: {
        uploader: {
            async uploadByFile(file) {
                const formData = new FormData();
                formData.append('image', file);
                const resp = await fetch('/api/content/media/editor-upload', {
                    method: 'POST',
                    body: formData,
                });
                const data = await resp.json();
                if (data.success) {
                    if (data.inline) {
                        contentLog(`ğŸ–¼ï¸ Image inlined (${formatMediaSize(data.size_bytes)})`);
                    } else {
                        const opt = data.optimized
                            ? ` Â· optimized ${formatMediaSize(data.original_size_bytes)} â†’ ${formatMediaSize(data.size_bytes)}`
                            : '';
                        const tier = data.storage === 'large' ? ' [release]' : '';
                        contentLog(`ğŸ–¼ï¸ Image â†’ vault: ${data.media_id} (${formatMediaSize(data.size_bytes)}${opt}${tier})`);
                    }
                } else {
                    contentLog(`âŒ Image upload failed: ${data.error}`, true);
                }
                return data;
            },
            async uploadByUrl(url) {
                const resp = await fetch('/api/content/media/editor-fetch-url', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url }),
                });
                return await resp.json();
            },
        },
        // In admin preview, resolve media:// URIs to preview endpoint
        actions: [],
    },
};
}

let contentEditorReady = false;

contentEditor = new EditorJS({
holder: 'content-editorjs',
data: data,
tools: toolConfig,
placeholder: 'Start writing your article...',
onChange: () => {
    // Ignore onChange events fired during editor initialization
    if (!contentEditorReady) return;
    contentDirty = true;
    const statusEl = document.getElementById('content-save-status');
    if (statusEl) statusEl.style.opacity = '0';
},
minHeight: 300,
});

try {
await contentEditor.isReady;
// Wait for images to load â€” they fire onChange when they render
setTimeout(() => {
    contentEditorReady = true;
    contentDirty = false;  // Clear any false positives from image loads
}, 1500);
} catch (e) {
console.warn('Editor.js ready warning:', e);
contentEditorReady = true;
}
}

// â”€â”€ Lazy-load Editor.js scripts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let editorScriptsLoaded = false;

function loadScript(src) {
return new Promise((resolve, reject) => {
const script = document.createElement('script');
script.src = src;
script.onload = resolve;
script.onerror = reject;
document.head.appendChild(script);
});
}

async function loadEditorScripts() {
if (editorScriptsLoaded) return;
const cdn = 'https://cdn.jsdelivr.net/npm';
try {
await loadScript(`${cdn}/@editorjs/editorjs@2.30/dist/editorjs.umd.min.js`);
// Load tools in parallel
await Promise.allSettled([
loadScript(`${cdn}/@editorjs/header@2.8/dist/header.umd.min.js`),
loadScript(`${cdn}/@editorjs/list@1.9/dist/list.umd.min.js`),
loadScript(`${cdn}/@editorjs/image@2.9/dist/image.umd.min.js`),

loadScript(`${cdn}/@editorjs/quote@2.7/dist/quote.umd.min.js`),
loadScript(`${cdn}/@editorjs/code@2.9/dist/code.umd.min.js`),
loadScript(`${cdn}/@editorjs/table@2.4/dist/table.umd.min.js`),
loadScript(`${cdn}/@editorjs/warning@1.4/dist/warning.umd.min.js`),
loadScript(`${cdn}/@editorjs/delimiter@1.4/dist/delimiter.umd.min.js`),
]);
editorScriptsLoaded = true;
} catch (e) {
console.error('Failed to load Editor.js scripts:', e);
}
}

// â”€â”€ Save article â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentSave() {
if (!contentEditor || !contentSelectedSlug) return;

const saveBtn = document.getElementById('content-save-btn');
saveBtn.disabled = true;
saveBtn.textContent = 'â³ Saving...';

try {
const rawOutputData = await contentEditor.save();
const outputData = contentRewriteMediaUrls(rawOutputData, 'toMedia');
const encrypt = document.getElementById('content-encrypt-toggle').checked;

if (encrypt && !contentEncryptionAvailable) {
contentLog('âš ï¸ Cannot encrypt â€” CONTENT_ENCRYPTION_KEY is not set.\nGo to Secrets â†’ Security to configure it.', true);
return;
}

const resp = await fetch(`/api/content/articles/${contentSelectedSlug}`, {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                content: outputData,
                encrypt: encrypt,
                metadata: {
                    min_stage: document.getElementById('content-meta-stage').value,
                    include_in_nav: document.getElementById('content-meta-nav').checked,
                    pin_to_top: document.getElementById('content-meta-pin').checked,
                },
            }),
});
const data = await resp.json();

if (data.success) {
contentDirty = false;
contentOriginalData = outputData;
const encLabel = data.encrypted ? 'ğŸ”’ encrypted' : 'ğŸ“„ plaintext';
contentLog(`âœ… Saved "${contentSelectedSlug}" as ${encLabel}`);
if (data.media_reconciled > 0) {
    contentLog(`ğŸ”„ ${data.media_reconciled} media file(s) updated to match`);
}
// Show save status
const statusEl = document.getElementById('content-save-status');
if (statusEl) {
    statusEl.textContent = 'âœ… Saved Â· Sync to publish';
    statusEl.style.opacity = '1';
}
// Refresh list to update badges
await loadContent();
renderContentList();
// Invalidate media cache so panel shows updated refs/captions
mediaLoaded = false;
} else {
contentLog(`âŒ Save failed: ${data.error}`, true);
}
} catch (error) {
contentLog(`âŒ Save error: ${error.message}`, true);
} finally {
saveBtn.disabled = false;
saveBtn.textContent = 'ğŸ’¾ Save';
}
}

// â”€â”€ Discard changes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentDiscard() {
if (!contentDirty) return;
if (!confirm('Discard all changes?')) return;
contentDirty = false;
if (contentOriginalData) {
await initContentEditor(contentOriginalData);
}
contentLog('â†©ï¸ Changes discarded.');
}

// â”€â”€ New article â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentNewArticle() {
const slug = prompt('Article slug (lowercase, underscores):', '');
if (!slug) return;

// Validate slug
const clean = slug.trim().toLowerCase().replace(/[^a-z0-9_]/g, '_').replace(/_+/g, '_');
if (!clean) {
alert('Invalid slug. Use lowercase letters, numbers, and underscores.');
return;
}

// Check if already exists
if (contentArticles.some(a => a.slug === clean)) {
alert(`Article "${clean}" already exists. Select it from the list.`);
return;
}

// Create default content
const defaultContent = {
time: Date.now(),
blocks: [
{ type: 'header', data: { text: clean.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()), level: 1 } },
{ type: 'paragraph', data: { text: '' } },
],
version: '2.28.0',
};

try {
const resp = await fetch(`/api/content/articles/${clean}`, {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({ content: defaultContent, encrypt: false }),
});
const data = await resp.json();
if (data.success) {
contentLog(`âœ… Created article "${clean}"`);
await loadContent();
contentSelectArticle(clean);
} else {
contentLog(`âŒ Failed: ${data.error}`, true);
}
} catch (error) {
contentLog(`âŒ Error: ${error.message}`, true);
}
}

// â”€â”€ Delete article â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentDeleteArticle() {
if (!contentSelectedSlug) return;
if (!confirm(`Permanently delete "${contentSelectedSlug}"? This cannot be undone.`)) return;

try {
const resp = await fetch(`/api/content/articles/${contentSelectedSlug}`, {
    method: 'DELETE',
});
const data = await resp.json();
if (data.success) {
    contentLog(`ğŸ—‘ï¸ Deleted "${contentSelectedSlug}"`);

    // Offer to delete orphaned media
    if (data.orphaned_media && data.orphaned_media.length > 0) {
        const names = data.orphaned_media.map(m => `  â€¢ ${m.original_name} (${m.id})`).join('\n');
        if (confirm(`${data.orphaned_media.length} media file(s) are no longer referenced by any article:\n\n${names}\n\nDelete them?`)) {
            for (const m of data.orphaned_media) {
                try {
                    const delResp = await fetch(`/api/content/media/${m.id}`, { method: 'DELETE' });
                    const delData = await delResp.json();
                    if (delData.success) {
                        contentLog(`ğŸ—‘ï¸ Deleted orphaned media: ${m.original_name}`);
                    }
                } catch (e) {
                    contentLog(`âŒ Failed to delete ${m.id}: ${e.message}`, true);
                }
            }
            mediaLoaded = false;
        }
    }

    contentSelectedSlug = null;
    contentDirty = false;
    resetContentEditor();
    await loadContent();
} else {
    contentLog(`âŒ Delete failed: ${data.error}`, true);
}
} catch (error) {
contentLog(`âŒ Error: ${error.message}`, true);
}
}

// â”€â”€ Encrypt / decrypt in-place â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function contentEncryptInPlace() {
if (!contentSelectedSlug) return;
const art = contentArticles.find(a => a.slug === contentSelectedSlug);
if (!art) return;

if (art.encrypted) {
// Decrypt
try {
const resp = await fetch(`/api/content/articles/${contentSelectedSlug}/decrypt`, { method: 'POST' });
const data = await resp.json();
if (data.success) {
contentLog(`ğŸ”“ Decrypted "${contentSelectedSlug}" â€” now stored as plaintext`);
await loadContent();
contentSelectArticle(contentSelectedSlug);
} else {
contentLog(`âŒ ${data.error}`, true);
}
} catch (e) {
contentLog(`âŒ Error: ${e.message}`, true);
}
} else {
// Encrypt
if (!contentEncryptionAvailable) {
contentLog('âš ï¸ Cannot encrypt â€” CONTENT_ENCRYPTION_KEY is not set.', true);
return;
}
try {
const resp = await fetch(`/api/content/articles/${contentSelectedSlug}/encrypt`, { method: 'POST' });
const data = await resp.json();
if (data.success) {
contentLog(`ğŸ”’ Encrypted "${contentSelectedSlug}" â€” now stored encrypted in repo`);
await loadContent();
contentSelectArticle(contentSelectedSlug);
} else {
contentLog(`âŒ ${data.error}`, true);
}
} catch (e) {
contentLog(`âŒ Error: ${e.message}`, true);
}
}
}

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function resetContentEditor() {
document.getElementById('content-editor-slug').textContent = 'Select an article';
document.getElementById('content-editor-badges').innerHTML = '';
document.getElementById('content-editor-empty').style.display = 'flex';
document.getElementById('content-editorjs-wrap').style.display = 'none';
document.getElementById('content-editor-controls').style.display = 'none';
document.getElementById('content-meta-panel').style.display = 'none';
if (contentEditor) {
try { contentEditor.destroy(); } catch (e) {}
contentEditor = null;
}
}

function updateEncryptNote() {
const note = document.getElementById('content-encrypt-note');
const checked = document.getElementById('content-encrypt-toggle').checked;
if (checked && !contentEncryptionAvailable) {
note.innerHTML = '<span style="color: var(--danger);">âš ï¸ Key not set â€” encryption will fail</span>';
} else if (checked) {
note.textContent = 'Content will be encrypted before saving to disk';
} else {
note.textContent = 'Content will be saved as plaintext';
}
}

// Attach toggle listener
document.getElementById('content-encrypt-toggle')?.addEventListener('change', updateEncryptNote);

function contentLog(message, isError = false) {
const terminal = document.getElementById('content-terminal');
const timestamp = new Date().toLocaleTimeString();
if (isError) {
terminal.className = 'terminal error';
} else {
terminal.className = 'terminal';
}
terminal.textContent = `[${timestamp}] ${message}`;
}

// â”€â”€ Media URL rewriting for Editor.js â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const MEDIA_URI_PREFIX = 'media://';
const MEDIA_PREVIEW_PREFIX = '/api/content/media/';

/**
 * Rewrite media:// URIs â†” preview endpoint URLs in Editor.js data.
 *
 * @param {Object} editorData - Editor.js output data (with blocks array)
 * @param {string} direction - 'toPreview' or 'toMedia'
 * @returns {Object} Deep clone with rewritten URLs
 */
function contentRewriteMediaUrls(editorData, direction) {
    if (!editorData || !editorData.blocks) return editorData;
    
    // Deep clone so we don't mutate the original
    const clone = JSON.parse(JSON.stringify(editorData));
    
    for (const block of clone.blocks) {
        if (block.type !== 'image') continue;
        
        const fileObj = block.data && block.data.file;
        if (!fileObj || !fileObj.url) continue;
        
        const url = fileObj.url;
        
        if (direction === 'toPreview' && url.startsWith(MEDIA_URI_PREFIX)) {
            // media://img_001 â†’ /api/content/media/img_001/preview
            const mediaId = url.slice(MEDIA_URI_PREFIX.length);
            fileObj.url = `${MEDIA_PREVIEW_PREFIX}${mediaId}/preview`;
        } else if (direction === 'toMedia' && url.startsWith(MEDIA_PREVIEW_PREFIX)) {
            // /api/content/media/img_001/preview â†’ media://img_001
            const match = url.match(/^\/api\/content\/media\/([^/]+)\/preview$/);
            if (match) {
                fileObj.url = `${MEDIA_URI_PREFIX}${match[1]}`;
            }
        }
        // data: and https:// URLs pass through unchanged
    }
    
    return clone;
}

// formatMediaSize is used by both _content.html and _media.html
if (typeof formatMediaSize === 'undefined') {
function formatMediaSize(bytes) {
    if (bytes === 0) return '0 B';
    const units = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    const val = (bytes / Math.pow(1024, i)).toFixed(i === 0 ? 0 : 1);
    return `${val} ${units[i]}`;
}
}